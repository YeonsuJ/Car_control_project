# Status 부 파일 분할 및 코드 최적화, CAN 개선, ADC 배터리측정 로직 추가 (v1.6.0)

## 파일 분할 및 코드 최적화 목적

기존 status_v1.5.0은 모든 기능이 main.c 하나에 집중되어 있어 코드의 복잡도가 높고 유지보수가 어려웠다. 특히, CAN 수신 처리, OLED 출력, 배터리 전압 측정 및 계산 등의 기능이 하나의 루프에서 혼합되어 처리되며, 기능 간의 명확한 역할 분리 부족, 디버깅의 어려움, 확장성 저하 등의 문제가 존재했다.

이를 해결하기 위해 status_v1.6.0에서는 다음과 같은 방식으로 기능별 모듈화 및 파일 분할을 수행하였다:

---

## 주요 변경 사항

### 1. 파일 분할 (모듈화)

기존 main.c의 역할을 분산시키고, 기능별 독립성을 확보하기 위해 아래와 같이 파일을 분할함

- `can_handler.c/.h` (CAN 수신 핸들러)
    - 역할: 거리 조건에 따른 CAN 수신 데이터를 처리하고, 수신된 RxData[0] 값을 해석하여 시스템 상태(Status: SAFE, DETECTED 등)를 판단함.
    - 주요 함수:
        - `CANHandler_Init()` : CAN 시작 및 필터/인터럽트 설정
        - `HAL_CAN_RxFifo1MsgPendingCallback()` : ID 0x6A5 수신 시 `RxData[0]` 값을 판별하여 OLED 상태 갱신 요청

- `battery_monitor.c/.h` (배터리 전압 모니터링)
    - 역할: ADC를 통해 배터리 전압을 측정하고, 이동 평균 필터와 보정 계수를 적용하여 안정적인 전압 값을 계산함. 해당 전압 값을 기준으로 퍼센트(%) 값을 산출하여 표시용으로 제공함.
    - 주요 함수:
        - `Read_Battery_Percentage()` : 보정 및 필터 적용된 전압 및 잔량(%) 반환
        - `Get_Averaged_Vout()` : 이동 평균 필터 적용

- `oled_display.c/.h` (OLED 출력 전담 모듈)
    - 역할: OLED 초기화 및 화면 갱신 처리. 배터리 상태 및 수신된 시스템 상태(Status: SAFE, DETECTED 등)를 화면에 출력함.
    - 주요 함수:
        - `OLED_Init()` : OLED 초기화 및 화면 클리어
        - `OLED_SetStatus()` : 상태 문자열 설정
        - `OLED_BatteryStatus()` : 배터리 퍼센트 및 전압을 화면에 출력

- `main.c`의 역할 변경
    - 역할: 시스템 초기화 이후 main 루프에서는 주기적으로 배터리 상태를 측정하고, 수신된 CAN 데이터에 따라 상태를 업데이트하는 등 전체 동작을 조율함. 각 기능은 각각의 전담 모듈로 위임되어, main.c는 중재자(Coordinator) 역할만 수행함.
    - 주요 처리 로직:
        - 100ms 주기로 배터리 전압 및 잔량 측정
        - `OLED_BatteryStatus()`를 통해 화면에 전압 및 상태 정보 표시
        - 수신된 CAN 메시지는 `can_handler.c`에서 직접 처리됨

### 2. 코드 구조 최적화

파일 분할을 통해 아래와 같은 코드 구조 개선을 진행하였다.

#### 데이터 흐름 명확화
- 내용: 
    - CAN으로 수신된 거리 위험 신호(RxData[0], 1: 위험 / 0: 안전)는 `can_handler.c` 내 인터럽트 콜백에서 직접 처리되며, `OLED_SetStatus()`를 호출하여 시스템 상태를 전역 문자열로 업데이트한다.
    - 배터리 전압은 `battery_monitor.c`에서 ADC를 통해 주기적으로 측정되며, 보정 및 이동 평균 필터를 거쳐 전압(V)과 잔량(%)으로 변환된다.
    - `main.c`는 일정 주기로 배터리 상태를 `OLED_BatteryStatus()`를 통해 출력한다.
- 효과 : 
    - CAN 수신 → 상태 문자열 업데이트 → OLED 표시, ADC 측정 → 전압/퍼센트 계산 → OLED 표시라는 단방향 흐름이 명확하게 분리되어 유지된다.
    - 전역 변수나 혼합된 처리 없이, 각 모듈의 데이터 입력과 출력 경로가 명확하여 디버깅, 추적, 기능 확장 등이 용이해짐

#### 캡슐화 및 책임 분리
- 내용 : 
    - `main.c`는 더 이상 하드웨어 세부 제어나 UI 업데이트를 직접 수행하지 않는다.
    - `can_handler.c`는 CAN 수신 및 수신 메시지 해석만을 담당하며, `OLED_SetStatus()`를 통해 상태 변경만 수행한다.
    - `battery_monitor.c`는 ADC 처리, 보정, 필터링, 퍼센트 계산을 전담한다.
    - `oled_display.c`는 OLED 초기화 및 출력 처리만을 담당하며, 외부로부터 받은 값만 출력하고 내부 로직을 드러내지 않음
- 효과 :
    - 각 기능별로 명확한 책임(Roles) 을 부여하여 모듈 간 결합도를 낮춤
    - 기능 추가나 수정 시 다른 모듈에 영향을 주지 않고 독립적으로 관리 가능
    - 각 모듈에 대해 단위 테스트 또는 독립 디버깅이 가능하여 유지보수성 향상 

### 3. 주요 개선 사항: 수신 반응 최적화 및 시스템 응답성 개선

status_v1.6.0에서는 CAN 수신 반응 처리 최적화와 OLED 출력 구조 정비, 배터리 모니터링 효율화를 통해 시스템 전반의 실시간 반응성과 안정성을 향상시켰다. 이를 통해 초음파 기반 거리 감지 결과를 수신한 후 OLED 출력까지의 End-to-End 반응 시간을 단축시켰으며, 실시간 상태 모니터링이 가능한 구조로 개선하였다.

#### 수신 응답 최적화
1. 인터럽트 기반 CAN 수신 구조 도입
    - 기존 Superloop 내 수신 대기 방식에서 벗어나, FIFO1 수신 인터럽트 콜백을 사용하여 거리 상태 메시지를 실시간으로 수신함.
    - 수신 후 즉시 `OLED_SetStatus()` 호출을 통해 지연 없이 사용자 피드백 가능.

2. OLED 출력 처리 구조 개선
    - 수신된 상태 문자열은 내부 전역 버퍼(`oled_line1`)에 저장되고, OLED는 별도 루프에서 주기적으로 배터리 상태와 함께 출력.
    - OLED 업데이트와 수신 처리를 분리하여 화면 깜빡임 최소화, 동시성 안정성 확보.

3. CAN 메시지 구조 경량화 수신 대응
    - 송신 노드에서는 `TxData[0]` 1바이트만 사용하며, status 노드는 해당 바이트만으로 상태 판별을 수행.
    - RxHeader.DLC 검증을 통해 불완전 패킷 방지, 수신 처리의 정확성과 안정성 강화.

#### 개선 효과
- 수신 반응 시간 단축
    - 거리 감지 후 CAN 수신 → 상태 출력까지의 전체 흐름이 인터럽트 기반으로 최적화되어, 사용자 피드백이 즉각적으로 이루어짐.

- 시스템 신뢰성 향상
    - 자동 재전송이 설정된 송신 노드 구조와 연동하여, status 노드에서는 누락 없는 신뢰성 있는 수신 처리가 가능해짐.

- 자원 효율성 개선
    - RxData의 유효 바이트만 활용하여 메모리 사용 최소화, OLED 출력도 최소한의 연산으로 수행하여 CPU 부하 절감.

- 확장성 확보
    - 추후 다양한 상태 메시지 유형 추가 또는 다중 센서 대응 시에도, 현재 구조에서 모듈 확장만으로 대응 가능하도록 설계됨.

---

## 주요 코드 설명

### `can_handler.h`: CAN 통신 모듈 인터페이스 정의
```c
#ifndef INC_CAN_HANDLER_H_
#define INC_CAN_HANDLER_H_

#include "main.h"

// =============================
// CAN 수신 메시지 설명:
// ID 0x6A5, RxData[0] = 거리 조건 (1: 위험, 0: 안전)
// =============================

extern CAN_FilterTypeDef sFilterConfig;
extern CAN_RxHeaderTypeDef RxHeader;
extern uint8_t RxData[8];

void CANHandler_Init(void);               // CAN 시작 + 필터 + 인터럽트 설정
void CAN_Filter_Config(CAN_HandleTypeDef *hcan_ptr);  // 필터 구성
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan);  // 수신 콜백

#endif /* INC_CAN_HANDLER_H_ */
```
- `CANHandler_Init()`
    - CAN 시작, 필터 설정, 인터럽트 활성화 수행

- `CAN_Filter_Config()`
    - ID 0x6A5만 수신할 수 있도록 마스크 필터 설정 (표준 ID, DLC 1 기준)

- `HAL_CAN_RxFifo1MsgPendingCallback()`
    - 수신 메시지를 읽고 RxData[0] 값에 따라 OLED 상태를 설정 (SAFE, DETECTED, UNKNOWN)

### `can_handler.c`: CAN 통신 모듈 구현
```c
#include "can_handler.h"
#include "can.h"
#include "oled_display.h"

CAN_FilterTypeDef sFilterConfig;
CAN_RxHeaderTypeDef RxHeader;
uint8_t RxData[8];

extern char oled_line1[21];

void CANHandler_Init(void)
{
    extern CAN_HandleTypeDef hcan;
    HAL_CAN_Start(&hcan);
    CAN_Filter_Config(&hcan);
}

void CAN_Filter_Config(CAN_HandleTypeDef *hcan_ptr)
{
    sFilterConfig.FilterActivation = CAN_FILTER_ENABLE;
    sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO1;
    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
    sFilterConfig.FilterIdHigh = 0x6A5 << 5;
    sFilterConfig.FilterIdLow = 0;
    sFilterConfig.FilterMaskIdHigh = 0x7FF << 5;
    sFilterConfig.FilterMaskIdLow = 0;
    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;

    if (HAL_CAN_ConfigFilter(&hcan, &sFilterConfig) != HAL_OK)
        Error_Handler();

    if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING) != HAL_OK)
        Error_Handler();
}

void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);

    if (RxHeader.StdId == 0x6A5 && RxHeader.DLC == 1)
    {
        if (RxData[0] == 1)
            OLED_SetStatus("DETECTED");
        else if (RxData[0] == 0)
            OLED_SetStatus("SAFE");
        else
            OLED_SetStatus("UNKNOWN");
    }
}
```
- 전역 변수 선언
    - `CAN_FilterTypeDef sFilterConfig`
    → CAN 수신 필터 설정 구조체 (ID/마스크 구성용)
    - `CAN_RxHeaderTypeDef RxHeader`
    → 수신된 CAN 메시지의 헤더 정보 저장 (ID, DLC 등)
    - `uint8_t RxData[8]`
    → 수신된 데이터 저장용 배열. 현재는 RxData[0]만 유효 (거리 상태: 1 or 0)

- `CANHandler_Init()`
    - 역할: 전체 CAN 수신 기능 초기화
    - 동작:
        - `HAL_CAN_Start()`로 CAN 주변장치 동작 시작
        - `CAN_Filter_Config()` 호출 → 수신 필터 및 인터럽트 설정

- `CAN_Filter_Config()`
    - 역할: 수신 필터 및 인터럽트 활성화 설정
    - 주요 설정 내용:
        - 필터 모드: ID 마스크 방식
        - 허용 ID: 0x6A5 (<<5 시프트는 11비트 ID를 필터 레지스터에 맞춤)
        - 마스크: 0x7FF (전체 11비트 일치 요구)
        - 필터 대상 FIFO: FIFO1
        - 인터럽트 활성화: `CAN_IT_RX_FIFO1_MSG_PENDING`

    → 이 설정으로, ID 0x6A5의 CAN 메시지가 도착하면 FIFO1 인터럽트로 수신된다.

- `HAL_CAN_RxFifo1MsgPendingCallback()`
    - 역할: 수신 메시지가 도착했을 때 자동 호출되는 인터럽트 콜백
    - 동작 흐름:
        1. HAL_CAN_GetRxMessage()로 수신 메시지를 RxHeader, RxData에 저장
        2. StdId가 0x6A5이고, 데이터 길이 DLC == 1이면 유효한 메시지로 간주
        3. RxData[0]의 값에 따라 OLED에 상태 문자열 설정
            - 1 → "DETECTED"
            - 0 → "SAFE"
            - 기타 → "UNKNOWN"

    → 이후 실제 OLED 화면 출력은 main.c 루프에서 OLED_BatteryStatus()를 통해 주기적으로 갱신됨

### `battery_monitor.h`: 배터리 측정 모듈 인터페이스 정의
```c
#ifndef INC_BATTERY_MONITOR_H_
#define INC_BATTERY_MONITOR_H_

#include "main.h"

float Read_Battery_Percentage(float* vout_ret);
float Get_Averaged_Vout(float new_sample);

#endif /* INC_BATTERY_MONITOR_H_ */
```

- `Read_Battery_Percentage()`
    - ADC로 측정한 값을 기반으로 배터리 전압을 계산하고, 보정 및 이동 평균 필터를 적용한 후 최종 퍼센트(%)로 환산하여 반환
    - `vout_ret` 포인터가 전달되면, 보정 및 필터가 적용된 Vout 값(전압)을 함께 반환

- `Get_Averaged_Vout()`
    - 최근 N개의 전압 샘플에 대한 이동 평균을 계산하여 노이즈를 줄이고 측정값의 안정성을 확보
    - 내부적으로 순환 버퍼를 사용하여 필터링 처리

이 헤더는 배터리 상태를 수치화하고 OLED 출력에 활용하기 위한 전압/잔량 계산 인터페이스를 제공함.
main.c에서는 이 모듈을 호출하여 주기적으로 배터리 상태를 모니터링할 수 있음.

### `battery_monitor.c`: 배터리 측정 모듈 구현
```c
#include "battery_monitor.h"
#include "adc.h"

// 이동 평균 필터 내부 변수
#define FILTER_SIZE 10
#define VOUT_CORRECTION_FACTOR 1.010f

// 내부 변수
float vout_buffer[FILTER_SIZE] = {0};  // 최근 10개 저장
uint8_t filter_index = 0;
uint8_t valid_sample_count = 0;

// 이동 평균 계산 함수
float Get_Averaged_Vout(float new_sample)
{
    vout_buffer[filter_index] = new_sample;
    filter_index = (filter_index + 1) % FILTER_SIZE;

    if (valid_sample_count < FILTER_SIZE)
        valid_sample_count++;

    float sum = 0.0f;
    for (int i = 0; i < valid_sample_count; i++)
        sum += vout_buffer[i];

    return sum / valid_sample_count;
}

//--- adc 전압출력 및 배터리 전압 → 퍼센트 계산 함수 ---
float Read_Battery_Percentage(float* vout_ret)
{
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint16_t adc_val = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);

    // 1. ADC → STM32 입력 전압 (Vout raw)
    float vout_raw = (3.3f * adc_val) / 4095.0f;

    // 2. 고정 보정 계수 적용
    float vout = vout_raw * VOUT_CORRECTION_FACTOR;

    // 3. 이동 평균 필터 적용
    vout = Get_Averaged_Vout(vout);

    // 4. 분압 비율에 따라 Vbat 복원 (ex: 11.46V → 2.92V 였다면)
    float vbat = vout * (11.46f / 2.92f);  // 실측 기반 비율

    // 5. Vbat → 퍼센트 환산 (최대 12.6V, 최소 9.6V 기준)
    float percent = ((vbat - 9.6f) / (12.6f - 9.6f)) * 100.0f;

    // 6. 범위 제한
    if (percent > 100.0f) percent = 100.0f;
    if (percent < 0.0f) percent = 0.0f;

    if (vout_ret != NULL)
        *vout_ret = vout;

    return percent;
}
```
- 전역 변수
    - vout_buffer[]: 최근 N개의 전압 샘플을 저장하는 이동 평균 필터용 버퍼
    - filter_index: 버퍼에서 새 샘플을 저장할 위치를 가리키는 인덱스
    - valid_sample_count: 필터 적용을 위한 유효 샘플 개수
    - VOUT_CORRECTION_FACTOR: ADC 오차 보정을 위한 계수 (실측 기반으로 조정)

- `Get_Averaged_Vout()` 함수
    - 새로운 전압 샘플을 버퍼에 저장하고, 최근 유효한 샘플들의 평균을 계산
    - 순환 버퍼(Circular Buffer) 구조를 사용해 메모리 효율을 높이고, 이동 평균을 통해 노이즈를 줄여 전압 측정의 안정성 확보

- `Read_Battery_Percentage()` 함수
    - 역할: ADC로 측정한 전압 값을 기반으로, 보정 및 필터링을 거쳐 배터리 잔량(%)과 전압(Vout) 을 계산
    - 동작 순서:
        1. ADC 값 읽기 → STM32 입력 전압(Vout) 계산
        2. 보정 계수 적용 (VOUT_CORRECTION_FACTOR)
        3. 이동 평균 필터로 노이즈 제거
        4. 실측 분압 비율을 통해 실제 배터리 전압(Vbat) 복원
    - 출력:
        - 반환값: 배터리 잔량(%)
        - vout_ret 포인터가 전달되면 필터링된 전압 값도 함께 반환

### `oled_display.h`: OLED 출력 관련 모듈 인터페이스
```c
#ifndef INC_OLED_DISPLAY_H_
#define INC_OLED_DISPLAY_H_

#include <stdint.h>

void OLED_Init(void);  // 외부에서 호출할 초기화 함수
// OLED 상태 정보 표시 함수
void OLED_BatteryStatus(const char* status, float percent, float vout);
void OLED_SetStatus(const char* status);


#endif /* INC_OLED_DISPLAY_H_ */
```

- OLED 화면에 시스템 상태(Status), 배터리 전압(V), 잔량(%)을 출력하기 위한 표시 전용 인터페이스 정의

- `OLED_Init(void)`
    - SSD1306 OLED 초기화 및 화면 클리어 수행
    - 시스템 시작 시 한 번 호출되어야 함

- `OLED_SetStatus(const char* status)`
    - 상태 문자열(예: "SAFE", "DETECTED", "UNKNOWN")을 내부 버퍼에 저장
    - 실제 출력은 별도 함수(OLED_BatteryStatus)에서 처리됨

- `OLED_BatteryStatus(const char* status, float percent, float vout)`
    - 상태 문자열, 배터리 퍼센트, 전압 정보를 OLED에 출력
    - status가 NULL일 경우 이전에 저장된 상태 문자열 사용
    - 호출 시 화면 전체를 갱신함

### `oled_display.c`: OLED 출력 관련 모듈 구현
```c
#include "oled_display.h"
#include "ssd1306.h"
#include "fonts.h"
#include <stdio.h>
#include <string.h>

static char oled_line1[21] = "Status: ---";
static char oled_line2[21];
static char oled_line3[21];

void OLED_Init(void)
{
    SSD1306_Init();
    SSD1306_Clear();
    SSD1306_UpdateScreen();
}

void OLED_SetStatus(const char* status)
{
    snprintf(oled_line1, sizeof(oled_line1), "Status: %s", status);
}

void OLED_BatteryStatus(const char* status, float percent, float vout)
{
    if (status != NULL)
        OLED_SetStatus(status); // 상태 문자열 갱신

    // 배터리 계산 후 문자열 구성
    snprintf(oled_line2, sizeof(oled_line2), "BAT: %3d%%", (uint8_t)(percent + 0.5f)); // 소수점 반올림
	snprintf(oled_line3, sizeof(oled_line3), "VOL: %.2fV", vout);

	SSD1306_Clear();
	SSD1306_GotoXY(0, 0);  SSD1306_Puts(oled_line1, &Font_7x10, 1);
	SSD1306_GotoXY(0, 20); SSD1306_Puts(oled_line2, &Font_7x10, 1);
	SSD1306_GotoXY(0, 30); SSD1306_Puts(oled_line3, &Font_7x10, 1);
	SSD1306_UpdateScreen();
}
```

- OLED 화면에 시스템 상태(Status), 배터리 잔량(%), 전압(V)을 구조적으로 출력하는 전담 모듈

- 전역 버퍼
    - oled_line1[21]
    → 상태 문자열 저장 (예: "Status: SAFE")
    - oled_line2[21]
    → 배터리 잔량 표시 문자열 (예: "BAT: 87%")
    - oled_line3[21]
    → 배터리 전압 표시 문자열 (예: "VOL: 3.04V")

    버퍼를 전역으로 유지하여 화면 갱신 시 일관된 문자열 구성을 보장함

- `OLED_Init()`
    - SSD1306 OLED 디스플레이 초기화
    - 화면 클리어 후 초기 상태 출력 준비

- `OLED_SetStatus(const char* status)`
    - 전달받은 상태 문자열을 oled_line1에 포맷팅하여 저장
    - 화면 즉시 갱신은 하지 않음 → 분리된 출력 함수에서 사용

- `OLED_BatteryStatus(const char* status, float percent, float vout)`
    - 선택적으로 상태 문자열을 갱신 (status != NULL일 경우)
    - 배터리 잔량과 전압을 텍스트로 포맷하여 oled_line2, oled_line3에 저장
    - 이후 OLED 화면을 클리어하고 모든 줄을 다시 출력
    - SSD1306_UpdateScreen() 호출로 실제 화면에 적용


### `main.c` 의 개선

기존(v1.5.0)의 main.c는 CAN 수신 처리, OLED 상태 표시, 배터리 전압 측정 및 계산 등 모든 기능이 한 파일 내에 직접 구현되어 있었으며, 기능 간 경계가 불명확하고 복잡하고 비직관적인 구조였다.

모든 로직이 while(1) 루프 내에서 처리되다 보니 유지보수가 어렵고, 각 기능의 수정 시 전체 코드에 영향을 미치는 밀접 결합 구조를 갖고 있었다.

v1.6.0에서는 기능별 모듈을 명확히 분리하여 main.c는 시스템 흐름만 제어하는 중재자 역할만 담당하도록 개선되었다:

```c
while (1)
{
    if (HAL_GetTick() - last_update_time >= 100)
    {
        last_update_time = HAL_GetTick();

        float vout = 0.0f;
        float percent = Read_Battery_Percentage(&vout);

        OLED_BatteryStatus(NULL, percent, vout);
    }
}
```
- CAN 수신 및 상태 해석은 `can_handler.c`에서 인터럽트 기반으로 처리
- 배터리 전압 측정 및 필터링은 `battery_monitor.c`에서 전담
- OLED 출력 구성 및 갱신은 `oled_display.c`에서 관리
- `main.c`는 단지 주기 체크 + 배터리 측정 + OLED 호출만 수행

이로 인해 얻는 이점은 다음과 같다:

- 가독성 향상 : main.c는 시스템의 흐름만 담당하며, 각 기능은 명확히 분리되어 있어 코드 구조가 직관적이고 이해하기 쉬움

- 유지보수 용이 : 오류 발생 시 해당 모듈만 점검하면 되므로, 디버깅 범위가 좁아지고 안정성이 향상됨

- 확장성 증가 : 새로운 센서, 표시 항목 추가, 경고 시스템 등 추가 시 기존 코드 수정 없이 모듈 추가만으로 확장 가능

- 재사용성 강화 : battery_monitor.c, oled_display.c, can_handler.c 등은 다른 프로젝트나 보드에서도 독립적으로 재사용 가능

- 실시간성 확보 기반 마련 : 로직이 모듈화되어 있으므로, 향후 FreeRTOS 등 RTOS 환경으로 이식 시 Task 단위로 쉽게 분리 가능

---

## 향후 확장 방향: RTOS 도입을 통한 시스템 고도화

status_v1.6.0에서는 CAN 수신 처리의 인터럽트 기반 분리, 배터리 모니터링 모듈화, OLED 출력 구조 정비, main.c 단순화를 통해 기존의 while(1) 중심 Superloop 구조를 RTOS 기반의 태스크 중심 처리 방식으로 전환할 수 있는 토대를 마련하였다.

앞으로 시스템의 실시간 반응성, 안정성, 확장성을 더욱 향상시키기 위해 FreeRTOS 도입을 계획하고 있다.

### RTOS 도입의 필요성 및 기대 효과
현재 구조는 다음과 같은 순차 흐름을 따른다:

1. CAN 메시지 수신 (인터럽트 기반)
2. 수신된 거리 상태에 따라 내부 상태 갱신
3. 주기적으로 배터리 전압 측정
4. OLED에 상태 및 배터리 정보 출력

    이러한 구조는 간단하지만, 기능이 추가되거나 시스템이 복잡해질수록 타 작업 간 간섭, 우선순위 충돌, 지연 누적 문제가 발생할 수 있다.

### RTOS 적용 시 기대 효과
- 실시간 응답성 확보
    - 수신 처리, 배터리 측정, OLED 갱신을 독립 태스크로 분리
    - 예:
        - DisplayTask: OLED 업데이트 전담
        - BatteryTask: 배터리 측정 및 필터링
        - CanTask: 수신 큐 모니터링 및 상태 해석
    각 태스크의 우선순위를 조절하여 시간 민감 작업의 지연을 방지

- 시스템 확장성 향상
    - 향후 자가 진단, 무선 설정 수신, EEPROM 상태 저장 등 기능을 기존 로직 수정 없이 태스크 단위로 추가 가능
    - 각 기능이 모듈화되어 있어 유지보수 및 테스트 용이

- 통신 안정성과 자원 보호 강화
    - 태스크 간 상태 정보는 Queue 또는 MessageBuffer를 통해 안전하게 전달
    - I2C(OLED), CAN 송신 등 공유 자원은 Mutex/Semaphore로 보호
    - 충돌 없는 안정적인 병렬 동작 가능

### 단계별 RTOS 적용 계획
- 1단계: 기능 분리 및 태스크화
    - BatteryTask: 일정 주기로 전압 측정 및 필터링 → 최신 값 유지
    - DisplayTask: 상태 문자열 + 배터리 정보 → OLED 출력
    - CanTask: CAN 수신 메시지를 큐로 전달 받고 해석

- 2단계: 태스크 간 통신 구조 설계
    - CAN 인터럽트 → Queue에 상태 전달
    - DisplayTask는 상태 큐 + 전압 값을 기반으로 화면 갱신
    - 배터리 전압은 Global 구조체 또는 QueueSet으로 통합 전달

- 3단계: 공유 자원 보호 적용
    - I2C, CAN, UART 등 주변장치 접근은 Mutex 또는 Binary Semaphore로 보호
    - 다중 접근 충돌 방지 및 시스템 신뢰성 확보