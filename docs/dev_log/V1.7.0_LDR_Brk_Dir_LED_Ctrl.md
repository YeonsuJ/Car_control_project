# LDR 기반 전/후진 및 브레이크 상태에 따라 전조등·후미등 제어 로직 추가 (v1.7.0)

## 📝 동작 요약

---

## 🔌 하드웨어 연결

<img src="../wiring_diagram/car_Integration_v1.5.0.png" alt="초음파-햅틱 can 통신 배선도" width="1000"/>

---

## ⚙️ STM32CubeMX 설정

---

## 💻 코드 주요 로직

### 1. Sensor → Status: 조도(LDR) 데이터 전송
Sensor MCU는 조도 센서(LDR)를 읽어 주변이 어두운지 판단하고, 그 결과를 CAN ID 0x6A5 로 전송한다.

```c
// ... main 함수 내부 ...
uint8_t light_condition = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); 
if (light_condition == GPIO_PIN_RESET) 
  TxData[1] = 1; // 어두움 플래그
else
  TxData[1] = 0; // 밝음 플래그

CAN_Send();
```
- HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0): LDR 센서가 연결된 PB0 핀의 디지털 상태를 읽음 (어두울 때 Low(RESET) 신호가 들어오도록 설계)
- if (light_condition == GPIO_PIN_RESET): 만약 핀 상태가 Low라면, 어둡다고 판단
- TxData[1] = 1: 전송할 데이터의 두 번째 바이트([1])에 '어두움'을 의미하는 1을 저장합니다. 밝을 경우 0을 저장
- CAN_Send(): 이 TxData 배열을 포함한 CAN 메시지를 네트워크로 전송

### 2. Central → Status: 주행 및 브레이크 상태 전송
Central MCU는 RF 통신을 바탕으로 차량의 전진/후진 및 브레이크 상태를 CAN ID 0x321 로 전송한다.

```c
// ... main 함수 내부, RF 명령 수신 후 ...
// 전진/후진 + 브레이크 상태를 CAN으로 전송
uint8_t dir = cmd.direction;
uint8_t brake = (cmd.brake_ms > 0) ? 1 : 0; // 브레이크 명령이 있으면 1
CAN_Send_DriveStatus(dir, brake);

// <can_handler.c>
void CAN_Send_DriveStatus(uint8_t direction, uint8_t brake_status)
{
    CAN_TxHeaderTypeDef TxHeader;
    uint8_t TxData[2];
    uint32_t TxMailbox;

    TxHeader.StdId = 0x321;  // 메시지 ID: 0x321
    TxHeader.DLC = 2;        // 데이터 길이: 2바이트

    TxData[0] = direction;   // Data[0]: 방향 (1: 전진, 0: 후진)
    TxData[1] = brake_status;// Data[1]: 브레이크 (1: 작동, 0: 해제)

    HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox);
}
```
- main 함수에서 RF 명령(cmd)으로부터 방향(direction)과 브레이크 작동 여부(brake_ms > 0)를 추출
- CAN_Send_DriveStatus() 함수를 호출
- 이 함수는 ID 0x321 로 CAN 메시지를 설정하고, 전달받은 direction과 brake_status 값을 각각 데이터의 첫 번째와 두 번째 바이트에 담아 전송함

### 3. Status: CAN 데이터 수신 및 LED 점등
Status MCU는 Sensor와 Central로부터 CAN 메시지를 수신하여 상태를 종합하고, 최종 조건에 따라 전조등, 후미등, 브레이크등을 제어한다.

```c
// <can_handler.c>
// CAN 수신 인터럽트 콜백 함수
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);

    // Sensor로부터 온 조도 정보 처리 (ID: 0x6A5)
    if (RxHeader.StdId == 0x6A5 && RxHeader.DLC == 2)
    {
        // ... (status_distance = RxData[0];) ...
        status_light = RxData[1]; // 조도 상태 저장
    }
    // Central로부터 온 주행 정보 처리 (ID: 0x321)
    else if (RxHeader.StdId == 0x321 && RxHeader.DLC == 2)
    {
        status_direction = RxData[0]; // 주행 방향 저장
        status_brake = RxData[1];     // 브레이크 상태 저장
    }

    // 수신된 최신 정보로 LED 상태 즉시 업데이트
    LEDControl_Update(status_light, status_direction, status_brake);
}


// <led_control.c>
void LEDControl_Update(uint8_t ldr_dark, uint8_t direction, uint8_t brake)
{
    // ... (모든 LED 핀 초기화: OFF) ...

    // 전조등/후미등 제어 (어두울 때만)
    if (ldr_dark == 1) // status_light가 1이면(어두우면)
    {
        if (direction == 1) // 전진 시
        {
            // 전조등 2개 ON
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
        }
        else if (direction == 0) // 후진 시
        {
            // 후미등 2개 ON
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, GPIO_PIN_SET);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_SET);
        }
    }

    // 브레이크등 제어 (밝기와 무관)
    if (brake > 0) // 브레이크 상태가 1이면
    {
        // 브레이크등 2개 ON
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET);
    }
}
```
- HAL_CAN_RxFifo1MsgPendingCallback: CAN 메시지가 수신될 때마다 자동으로 실행되는 인터럽트 함수
- ID 0x6A5 수신 시: RxData[1](조도 정보) 값을 status_light 변수에 저장함
- ID 0x321 수신 시: RxData[0](방향), RxData[1](브레이크) 값을 각각 status_direction, status_brake 변수에 저장
- LEDControl_Update() 호출: 어떤 메시지를 받든, 콜백 마지막에서 이 함수를 호출해 즉시 LED 상태를 갱신함
- LEDControl_Update 함수 내부:
  - 전조등: 어둡고(ldr_dark == 1) 전진기어에 위치할 때 (direction == 1)라는 두 가지 조건이 모두 만족될 때만 켜짐
  - 후미등: 어둡고(ldr_dark == 1) 후진기어에 위치할 때 (direction == 0) 켜짐
  - 브레이크등: 브레이크가 작동 중(brake > 0) 이면, 주변 밝기나 주행 방향과 관계없이 항상 켜짐

---

## 💡 향후 확장 및 개선 아이디어
- FreeRTOS 기반 CAN 통신 모듈화 및 태스크 분리
- 고속CAN 통신을 위해 buad rate 500k로 상향
- CAN_IT_TX_MAILBOX_EMPTY 인터럽트 활성화 및 관련 콜백 함수 구현
- 송신 큐 구조 도입 여부 검토 및 확장성 있는 송신 관리 구조 설계
- 전송 완료 이후 상태를 OLED 등으로 출력하여 통신 확인 피드백 구현 
