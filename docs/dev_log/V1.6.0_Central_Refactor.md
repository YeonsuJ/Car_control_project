# Central 부 파일 분할 및 코드 최적화, CAN 개선 (v1.6.0)

## 파일 분할 및 코드 최적화 목적

기존 central_v1.5.0은 모든 기능이 main.c 파일 하나에 집중되어 코드의 복잡도가 높고 유지보수가 어려웠다. 이를 해결하기 위해 v1.6.0에서는 RF 통신, 모터 제어, CAN 통신 로직을 각각의 독립적인 파일로 분리하여 모듈화했다. 이러한 구조 개선은 코드의 가독성과 재사용성을 높이고, 각 기능의 독립성을 확보하여 향후 기능 추가나 수정이 용이한 확장 가능한 구조를 만들기 위함이며, 특히 CAN 수신 데이터가 RF 통신으로 전달되는 과정을 명확히 하여 시스템 전체의 안정성과 신뢰도를 향상시키기 위한 목적이다.

---

## 주요 변경 사항

### 1. 파일 분할 (모듈화)

기존 `main.c`의 역할을 분산시키고, 기능별 독립성을 확보하기 위해 아래와 같이 파일을 분할함

- `can_handler.c/.h` (CAN 통신 핸들러)
    - 역할: CAN 필터 설정, 수신 인터럽트 처리, 수신 데이터의 거리 판단(위험/안전) 신호를 내부 상태 변수(can_distance_signal)에 저장하며, 해당 신호를 햅틱 제어 및 RF ACK 응답에 활용함.

    - 주요 함수 : `CANHandler_Init()` : CAN 시작 및 필터 초기화, `CAN_Filter_Config()` : 0x6A5 ID에 대한 필터 설정, `HAL_CAN_RxFifo1MsgPendingCallback()` : 수신된 거리 신호에 따라 햅틱 출력 및 상태 변수 업데이트

- `rf_handler.c/.h` (RF 통신 핸들러)
    - 역할 : 컨트롤러에서 수신된 주행 명령 패킷(Roll, Accel, Brake, 방향)을 파싱하고, CAN 수신 신호를 ACK 페이로드로 회신하여 핸들 상태에 반영되도록 처리함.

    - 주요 함수 : `RFHandler_Init()` : NRF24 수신 모드 초기화, `RFHandler_IrqCallback()` : EXTI 인터럽트 발생 시 수신 처리 준비, `RFHandler_GetNewCommand()` : 새로운 명령이 수신되었는지 확인 후 파싱하여 반환, `RFHandler_SetAckPayload()` : CAN 수신 거리 신호를 다음 ACK에 포함하도록 설정

- `motor_control.c/h` (모터 제어 모듈)
    - 역할 : RF에서 수신한 주행 명령에 따라 DC 모터와 서보 모터를 제어하며, 엔코더를 기반으로 실시간 RPM을 측정함. 속도 피드백은 외부 출력 또는 디버깅용으로 활용 가능.

    - 주요 함수 : `MotorControl_Init()` : PWM 및 엔코더 타이머 시작, 기본 방향 설정, `MotorControl_Update()` : roll, accel, brake, 방향에 따라 서보/DC 모터 제어 수행, `MotorControl_GetRPM()` : 주기적으로 계산된 현재 DC 모터 RPM 반환

- `main.c`의 역할 변경
    - 역할 : 초기화 이후 main() 루프에서 각 핸들러의 업데이트 함수들을 순차적으로 호출하는 중재자(Coordinator) 역할을 수행하며, 복잡한 제어/통신 로직은 전부 can_handler, rf_handler, motor_control로 위임됨.

### 2. 코드 구조 최적화

파일 분할을 통해 아래와 같은 코드 구조 개선을 진행하였다.

#### 데이터 흐름 명확화
- 내용: 
    - 컨트롤러에서 수신한 주행 명령은 VehicleCommand_t 구조체로 파싱되며, rf_handler 모듈 내에서 생성되어 motor_control로 전달된다.

    - 거리 감지 결과는 can_handler에서 수신된 값을 can_distance_signal 전역 변수로 저장하고, 이 값을 rf_handler에서 ACK 페이로드로 전송한다.

- 효과 : 모든 데이터가 명확한 흐름(→ 구조체 또는 상태 변수 → 다른 모듈의 함수 호출)을 따르므로 전역 변수의 혼용을 최소화하고, 데이터 추적이 직관적으로 가능해짐

#### 캡슐화 및 책임 분리
- 내용 : 
    - main.c는 더 이상 RF 버퍼, CAN 수신 패킷, 모터 PWM 값 등의 내부 세부 사항을 다루지 않는다.

    - 각 모듈은 자신이 담당하는 작업만 수행하고, 필요한 인터페이스 함수만 외부에 노출

        - 예: RFHandler_GetNewCommand()는 새 명령이 도착했는지만 알려주고, 파싱된 데이터를 반환
        - MotorControl_Update()는 받은 명령 구조체에 따라 내부 로직으로 모터 상태를 제어

- 효과 : 모듈 간 결합도가 낮아져 유지보수와 테스트가 쉬워지고, 코드 수정 시 다른 파일에 미치는 영향도 최소화

### 3. 주요 개선 사항: 통신 성능 최적화

v1.6.0에서는 사용자 조작에 대한 반응성을 크게 향상시키기 위해 RF 통신과 CAN 통신 모두에서 성능 최적화를 적용하였다. 이를 통해 End-to-End 지연 시간을 최소화하고, 조작에 대한 반응이 거의 실시간처럼 느껴질 수 있도록 개선하였다.

#### RF 통신 최적화
1. 데이터 송신 속도 향상
    - NRF24L01의 전송 속도를 기존 1Mbps → 2Mbps로 설정하여, 물리적인 전송 시간을 절반으로 단축.

2. 데이터 패킷 크기 최적화
    - 실제 사용하는 명령만 포함되도록 데이터 패킷 구조를 정리하여, 32바이트 → 8바이트로 축소.
    - 전송 시간 감소 + 버퍼 오버플로우 방지 + 응답 속도 향상.

#### CAN 통신 최적화
1. 보드레이트 향상
    - CAN의 Prescaler 값을 72 → 18로 조정하여, 125kbps → 500kbps의 고속 통신 환경으로 개선.
    - 더 짧은 시간에 메시지를 전송할 수 있어 거리 감지와 햅틱 응답의 딜레이가 감소.

2. 자동 재전송 및 오류 복구 기능 활성화
    - AutoBusOff와 AutoRetransmission 기능을 활성화하여, 일시적인 에러 상황에서도 자동으로 CAN 버스 복귀 및 재전송 수행.
    - 수동 복구 처리 없이 안정적인 실시간 통신을 보장.

3. 수신 ID와 데이터 길이 검증을 통한 유효성 강화
    - CAN 수신 콜백 함수(HAL_CAN_RxFifo1MsgPendingCallback)에서 수신된 메시지의 StdId와 DLC(Data Length Code)를 확인하여, 정확히 0x6A5 ID이며 데이터 길이가 1바이트일 때만 유효한 데이터로 처리하도록 구현.
    - 이를 통해 의도치 않은 메시지 처리로 인한 오동작을 예방하고, 중요한 거리 신호만을 반영함으로써 시스템의 안정성과 응답성을 향상시킴.
    - 특히 브로드캐스트 환경 또는 다중 노드 통신에서 ID 매칭 기반 필터링과 별개로 소프트웨어 레벨의 2차 검증 역할을 수행함.


#### 개선 효과

- End-to-End 지연 시간 최소화: RF → 중앙 MCU → CAN 수신 노드까지의 통신 흐름이 전반적으로 최적화되어, 컨트롤러 조작 시 햅틱 피드백이나 차량 응답이 즉시 반영되는 체감 반응성을 실현.

- 시스템 안정성 향상: 에러 상황에서도 자동 복구 기능이 동작하여, 조작 중 통신 끊김 없이 지속적인 운용 가능성 확보.

- 성능 기반 확장성 확보: 고속 통신 기반 구조를 통해 센서 추가, 다중 노드 통신 확장에도 대응할 수 있는 기반을 마련.

---

## 주요 코드 설명

### `can_handler.h`: CAN 통신 모듈 인터페이스 정의
```c
#ifndef INC_CAN_HANDLER_H_
#define INC_CAN_HANDLER_H_

#include "main.h"

// =============================
// CAN 수신 메시지 설명:
// ID 0x6A5, RxData[0] = 거리 조건 (1: 위험, 0: 안전)
// =============================

// ▶ 외부에서 접근할 수 있는 변수들
extern CAN_FilterTypeDef sFilterConfig;
extern CAN_RxHeaderTypeDef RxHeader;
extern uint8_t RxData[8];
extern volatile uint8_t can_distance_signal;

// ▶ 초기화 함수: CAN 시작 및 필터 설정
void CANHandler_Init(void);

// ▶ 필터 설정 함수: 특정 ID 수신 설정
void CAN_Filter_Config(CAN_HandleTypeDef *hcan_ptr);

// ▶ 수신 인터럽트 콜백 함수 (FIFO1 사용)
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan);

#endif /* INC_CAN_HANDLER_H_ */
```
- can_distance_signal: 거리 조건(위험 여부)을 저장해 다른 모듈(RF 등)에서 사용할 수 있도록 함
- HAL_CAN_RxFifo1MsgPendingCallback: CAN 수신 인터럽트에 의해 자동 호출됨

### `can_handler.c`: CAN 통신 모듈 구현
```c
#include "can_handler.h"
#include "can.h" // hcan 정의가 여기에 있을 수 있습니다.

// =============================
// CAN 수신(Rx) 패킷 구조 정의
// -----------------------------
// ▶ CAN 수신 ID:
//   - StdId: 0x6A5 (슬레이브 → 마스터)
//   - 필터 모드: 11비트 표준 ID, 마스크 0x7FF (전비트 일치)
// ▶ 수신 헤더 (RxHeader):
//   - RxHeader.StdId : 송신 측 ID 확인용 (0x6A5 expected)
//   - RxHeader.DLC   : 데이터 길이 (보통 1)
// ▶ 수신 데이터 (RxData):
//   - RxData[0] : 거리 조건 결과 (uint8_t, 거리값에따라 1 or 0 수신)
//   - RxData[1] ~ RxData[7] : 예비, 현재 미사용
// =============================

CAN_FilterTypeDef sFilterConfig;
CAN_RxHeaderTypeDef RxHeader;
uint8_t RxData[8];
volatile uint8_t can_distance_signal = 0;

void CANHandler_Init(void)
{
	extern CAN_HandleTypeDef hcan;
	HAL_CAN_Start(&hcan);
	CAN_Filter_Config(&hcan);
}

// can 필터 설정 및 인터럽트 활성화 함수
void CAN_Filter_Config(CAN_HandleTypeDef *hcan_ptr)
{
   // Configure the filter
   sFilterConfig.FilterActivation = CAN_FILTER_ENABLE;
   sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO1;
   sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
   sFilterConfig.FilterIdHigh = 0x6A5<<5;
   sFilterConfig.FilterIdLow = 0;
   sFilterConfig.FilterMaskIdHigh = 0x7FF<<5; // SET 0 to unfilter
   sFilterConfig.FilterMaskIdLow = 0;
   sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;

   if (HAL_CAN_ConfigFilter(&hcan, &sFilterConfig) != HAL_OK)
           Error_Handler(); // 실패 시 무한 루프 등 처리

   // Activate the notification
   if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING) != HAL_OK)
           Error_Handler(); // 실패 시 처리
}

// CAN 수신 인터럽트 콜백 함수 (FIFO1)
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
  HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);

  // 수신 ID와 데이터 길이 확인
  if (RxHeader.StdId == 0x6A5 && RxHeader.DLC == 1)
  {
	  // 거리 상태(0 또는 1)를 내부 변수에 저장
	  can_distance_signal = RxData[0];
  }
}
```
1. CAN 필터 설정 – 정밀 수신 필터링 (ID 0x6A5 고정 수신)
    - CAN_Filter_Config() 함수는 STM32의 ID 마스크 필터 방식 (IDMASK)을 활용하여 0x6A5 ID만 수신 허용.
    - 필터 마스크 0x7FF << 5로 11비트 전비트 일치 조건을 설정 → 다른 메시지는 하드웨어 레벨에서 차단됨.
    - 수신 대상 메시지는 FIFO1으로 설정되며, 해당 FIFO에 데이터가 도착하면 수신 인터럽트 자동 발생.
    - 목적:
        - 초음파 거리 감지용 CAN 메시지(0x6A5)만 선별적으로 처리하여 통신 효율과 안정성 향상.
        - 불필요한 소프트웨어 검사 없이 하드웨어 필터링으로 CPU 부하 최소화.

2. CAN 수신 인터럽트 처리 – Rx FIFO1 기반, 실시간 응답 구조
    - HAL_CAN_RxFifo1MsgPendingCallback() 함수는 FIFO1 수신 시 자동 호출되는 인터럽트 핸들러.
    - 내부에서 HAL_CAN_GetRxMessage()로 수신 데이터를 읽은 후, 다음 조건을 검사:
        - RxHeader.StdId == 0x6A5
        - RxHeader.DLC == 1
    - 조건이 일치하면 RxData[0]에 저장된 거리 감지 결과 (0 또는 1) 값을 전역 변수 can_distance_signal에 저장.
    - 목적:
        - 초음파 거리 감지 결과를 즉시 햅틱 출력/경고에 반영.
        - can_distance_signal은 RF 응답 페이로드, OLED 표시, 로직 판단 등에 참조됨.
        - 조건 불일치 시 무시 처리 → 데이터 유효성 검증 강화.

3. 모듈 초기화 – 통신 시작과 인터럽트 설정 통합 처리
    - CANHandler_Init() 함수는 다음 세 가지 초기화 절차를 일괄 수행:
        - HAL_CAN_Start() : CAN 동작 시작
        - CAN_Filter_Config() : ID 필터 등록 및 FIFO 지정
        - HAL_CAN_ActivateNotification() : FIFO1 수신 인터럽트 활성화
    - 목적:
        - 메인 루프에서 CAN 수신을 직접 폴링하지 않아도 되는 비동기 이벤트 기반 구조 구성.
        - 시스템 부팅 시 자동으로 통신이 준비되며, 완전한 자동 수신-처리 체계 구현

### `rf_handler.h`: RF 통신 모듈 인터페이스 정의
```c
#ifndef INC_RF_HANDLER_H_
#define INC_RF_HANDLER_H_

#include "main.h"
#include <stdbool.h>

// ▶ 수신된 주행 명령 데이터를 담는 구조체
typedef struct {
    float roll;
    uint16_t accel_ms;
    uint16_t brake_ms;
    uint8_t direction;
} VehicleCommand_t;

// ▶ NRF24 초기화 (수신모드 설정)
void RFHandler_Init(void);

// ▶ EXTI 인터럽트 발생 시 호출 (nRF IRQ 핀)
void RFHandler_IrqCallback(void);

// ▶ 다음 ACK 페이로드 데이터를 설정 (e.g. can_distance_signal)
void RFHandler_SetAckPayload(uint8_t signal);

// ▶ 새로운 주행 명령 수신 여부 확인 및 파싱
bool RFHandler_GetNewCommand(VehicleCommand_t* command);

#endif /* INC_RF_HANDLER_H_ */
```
- 외부에서 사용할 수 있는 초기화 함수, IRQ 콜백, ACK 설정 및 수신 명령 파싱 기능이 선언되어 있음

### `rf_handler.c`: RF 통신 모듈 구현
```c
#include "rf_handler.h"
#include "NRF24.h"
#include "NRF24_reg_addresses.h"
#include <string.h>

// ▶ 페이로드 크기 정의
#define RX_PAYLOAD_SIZE 8
#define ACK_PAYLOAD_SIZE 2

// ▶ 내부 상태 변수
static volatile uint8_t nrf_irq_flag = 0;             // IRQ 발생 여부
static uint8_t ack_response[ACK_PAYLOAD_SIZE] = {0};  // 다음 전송할 ACK 페이로드

// ▶ NRF24 모듈 초기화 (수신 전용)
void RFHandler_Init(void)
{
    static uint8_t rx_addr[5] = {0x45, 0x55, 0x67, 0x10, 0x21};

    csn_high(); HAL_Delay(5); ce_low();
    nrf24_init();
    nrf24_auto_ack_all(enable);
    nrf24_en_ack_pld(enable);       // ACK payload 활성화
    nrf24_dpl(disable);
    nrf24_set_crc(enable, _1byte);
    nrf24_tx_pwr(_0dbm);
    nrf24_data_rate(_2mbps);        // 속도 설정
    nrf24_set_channel(90);
    nrf24_set_addr_width(5);
    nrf24_open_rx_pipe(1, rx_addr);
    nrf24_pipe_pld_size(1, RX_PAYLOAD_SIZE);
    nrf24_listen();
}

// ▶ 외부 인터럽트 핸들러에서 호출되는 콜백
void RFHandler_IrqCallback(void)
{
    nrf_irq_flag = 1;
}

// ▶ 다음 ACK 페이로드 설정 함수
void RFHandler_SetAckPayload(uint8_t signal)
{
    ack_response[0] = signal;  // can_distance_signal 등 설정
}

// ▶ 새 데이터 수신 여부 확인 및 명령 파싱
bool RFHandler_GetNewCommand(VehicleCommand_t* command)
{
    if (!nrf_irq_flag) return false;

    nrf_irq_flag = 0;
    uint8_t status = nrf24_r_status();

    if (status & (1 << RX_DR))
    {
        uint8_t rx_buffer[RX_PAYLOAD_SIZE] = {0};
        nrf24_receive(rx_buffer, RX_PAYLOAD_SIZE);

        // ACK 페이로드 응답 전송
        nrf24_transmit_rx_ack_pld(1, ack_response, ACK_PAYLOAD_SIZE);
        nrf24_clear_rx_dr();

        if (rx_buffer[0] == 1) // 주행 명령
        {
            int16_t roll_encoded;
            memcpy(&roll_encoded, &rx_buffer[1], sizeof(int16_t));
            command->roll = ((float)roll_encoded) / 100.0f;

            memcpy(&command->accel_ms, &rx_buffer[3], sizeof(uint16_t));
            memcpy(&command->brake_ms, &rx_buffer[5], sizeof(uint16_t));
            command->direction = rx_buffer[7];

            return true;
        }
    }

    return false;
}
```

- NRF24 수신 초기화
    - RFHandler_Init()은 NRF24L01을 수신 모드로 설정하고, 자동 응답(ACK) + 페이로드 포함 전송 기능을 활성화한다.
    - 데이터 레이트 2Mbps, 채널 90, 주소 폭 5바이트, 파이프 1번 사용 등 실시간 제어에 최적화된 설정이 적용된다.
    - 목적: 컨트롤러와의 고속 양방향 통신을 위한 하드웨어 설정

- 인터럽트 기반 비동기 수신
    - EXTI 인터럽트가 발생하면 nrf_irq_flag를 세팅하여 메인 루프나 작업자 함수가 비동기적으로 수신 처리를 할 수 있도록 설계
    - 목적: 폴링이 아닌 인터럽트 기반 수신 처리 → CPU 점유율 최소화

- 주행 명령 파싱 및 구조화
    - rx_buffer에서 받은 바이트를 해석하여 VehicleCommand_t 구조체로 변환
        - roll (int16 → float 변환)
        - accel_ms, brake_ms, direction
    - 목적: 실수 없이 정형화된 주행 명령 데이터로 모터 제어 모듈에 직접 전달 가능

- ACK 페이로드 기반 상태 응답
    - RF 수신 시 nrf24_transmit_rx_ack_pld()를 통해 즉시 ACK 페이로드 전송.
    - can_handler에서 받은 can_distance_signal을 사전에 ack_response[0]에 담아 사용.
    - 목적: 컨트롤러에서 즉시 거리 상태 확인 가능, 햅틱 피드백 동기화

### `motor_control.h` : 모터 제어 모듈 인터페이스
```c
#ifndef INC_MOTOR_CONTROL_H_
#define INC_MOTOR_CONTROL_H_

#include "main.h"
#include "rf_handler.h" // VehicleCommand_t 사용을 위해 포함

/**
 * @brief 모든 모터 관련 주변장치(PWM, 방향핀, 엔코더 등) 초기화
 */
void MotorControl_Init(void);

/**
 * @brief 수신된 주행 명령에 따라 서보 및 DC모터를 제어
 * @param command: roll, accel, brake, direction 정보를 담은 구조체
 */
void MotorControl_Update(const VehicleCommand_t* command);

/**
 * @brief 현재 DC 모터의 RPM을 반환
 */
float MotorControl_GetRPM(void);

#endif /* INC_MOTOR_CONTROL_H_ */
```
- DC 모터 및 서보 모터의 제어 기능을 외부에 제공하며, 주행 명령 구조체(VehicleCommand_t) 기반 제어 함수 및 RPM 측정 함수가 선언되어 있다.

### `motor_control..c`: 모터 제어 모듈 구현
```c
#include "motor_control.h"
#include <math.h> // fabsf

// 타이머 외부 참조 (STM32CubeMX에서 생성된 핸들 사용)
extern TIM_HandleTypeDef htim1; // DC 모터 PWM
extern TIM_HandleTypeDef htim2; // 서보 모터 PWM
extern TIM_HandleTypeDef htim4; // 엔코더 입력

// 내부 설정 변수
static TIM_HandleTypeDef* dc_motor_htim = &htim1;
static uint32_t dc_motor_channel = TIM_CHANNEL_4;

static TIM_HandleTypeDef* servo_htim = &htim2;
static uint32_t servo_channel = TIM_CHANNEL_3;

static float motor_rpm = 0.0f;

// === RPM 계산용 매크로 및 상수 ===
#define PPR 11
#define GEAR_RATIO 21.3f
#define TICKS_PER_REV (PPR * GEAR_RATIO * 4)

// 모터 방향 전환 매크로
#define MOTOR_FORWARD()  do { HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); } while(0)
#define MOTOR_BACKWARD() do { HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET); } while(0)

typedef enum {
    DIRECTION_BACKWARD = 0,
    DIRECTION_FORWARD  = 1
} MotorDirection_t;

// === 초기화 함수 ===
void MotorControl_Init(void)
{
    HAL_TIM_PWM_Start(dc_motor_htim, dc_motor_channel);
    HAL_TIM_PWM_Start(servo_htim, servo_channel);
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
    MOTOR_FORWARD(); // 기본 방향
}

// === 전체 명령 기반 제어 함수 ===
void MotorControl_Update(const VehicleCommand_t* command)
{
    Update_Motor_RPM();
    Update_MotorDirection((MotorDirection_t)command->direction);
    Control_Servo(command->roll);
    Control_DcMotor(command->accel_ms, command->brake_ms);
}

// === 현재 RPM 반환 함수 ===
float MotorControl_GetRPM(void)
{
    return motor_rpm;
}

// === 내부 전용 함수 ===

static void Update_Motor_RPM(void)
{
    static int16_t last_encoder = 0;
    static uint32_t last_tick = 0;
    uint32_t now = HAL_GetTick();

    if (now - last_tick >= 100) // 100ms 주기
    {
        last_tick = now;
        int16_t enc = (int16_t)__HAL_TIM_GET_COUNTER(&htim4);
        int16_t delta = enc - last_encoder;
        last_encoder = enc;

        motor_rpm = fabsf(((float)delta / TICKS_PER_REV) * 10.0f * 60.0f);
    }
}

static void Control_Servo(float roll)
{
    if (roll < -90.0f) roll = -90.0f;
    if (roll >  90.0f) roll =  90.0f;
    float angle = roll + 90.0f;
    uint16_t pwm = (uint16_t)(1200 + (angle / 180.0f) * (1900 - 1200));
    __HAL_TIM_SET_COMPARE(servo_htim, servo_channel, pwm);
}

static void Control_DcMotor(uint16_t accel_ms, uint16_t brake_ms)
{
    static int16_t duty = 0;
    const int16_t accel_step = 50;
    const int16_t brake_step = 100;
    const int16_t max_duty = 1000;

    if (brake_ms > 0) duty -= brake_step;
    else if (accel_ms > 0) {
        if (duty == 0) duty = 300;
        duty += accel_step;
    } else {
        duty -= accel_step;
    }

    if (duty < 0) duty = 0;
    if (duty > max_duty) duty = max_duty;
    __HAL_TIM_SET_COMPARE(dc_motor_htim, dc_motor_channel, duty);
}

static void Update_MotorDirection(MotorDirection_t direction)
{
    static MotorDirection_t prev = DIRECTION_FORWARD;
    if (direction != prev) {
        prev = direction;
        if (direction == DIRECTION_FORWARD) MOTOR_FORWARD();
        else MOTOR_BACKWARD();
    }
}
```
- PWM 기반 제어
    - 서보 모터: roll 값을 -90° +90° 범위로 매핑 → 1200 1900us PWM 출력
    - DC 모터: PWM duty 비율을 accel_ms, brake_ms에 따라 가감속 제어
    - 목적: 사용자 입력에 따라 정밀한 속도 및 조향 제어

- DC 모터 방향 제어 (GPIO)
    - IN1/IN2 핀을 이용한 정/역회전 제어 (MOTOR_FORWARD(), MOTOR_BACKWARD() 매크로)
    - 이전 방향 상태와 비교 후 변경 시에만 핀 전환
    - 목적: 방향 전환 시 노이즈 및 급격한 반전 방지

- 엔코더 기반 실시간 RPM 측정
    - 100ms 주기로 엔코더 카운터 변화량 계산 → 기어비와 PPR 고려하여 RPM 산출
    - fabsf()를 통해 항상 양수 출력
    - 목적: 속도 피드백 기반 향후 PID 제어 등 확장 기반 마련

- 명령 구조체 기반 전체 제어 통합
    - MotorControl_Update() 함수는 외부에서 받은 VehicleCommand_t 구조체 하나만으로 전체 모터 상태(조향, 가감속, 방향)를 통합 제어
    - 목적: 외부 모듈과의 연계성을 높이고 코드 유지보수 간소화

### `main.c` 의 개선

이전의 main.c는 모든 기능이 한 파일에 집중되어 있었다. RF 수신, 데이터 파싱, 모터 제어, 방향 전환, CAN 응답 생성까지 모두 main() 함수 안에서 직접 처리했다. 구조가 복잡하고 가독성이 낮았으며, 유지보수나 기능 확장 시 전체 코드에 영향을 주기 쉬웠다.

반면 v1.6.0 구조에서는 이러한 책임을 모듈별로 분리했다. main() 함수는 다음과 같이 단순화되었다:

```c
while (1)
{
    if (RFHandler_GetNewCommand(&command))
    {
        MotorControl_Update(&command);
    }

    RFHandler_SetAckPayload(can_distance_signal);
}
```

이제 main.c는 RF로부터 명령을 받아 모터를 제어하고, 거리 상태를 응답에 포함하는 중재자 역할만 수행한다. 세부 로직은 rf_handler, motor_control, can_handler 등 각 파일에서 처리된다.

이로 인해 얻는 이점은 다음과 같다:

- 가독성 향상: 흐름이 단순하고 직관적이다.
- 유지보수 용이: 문제 발생 시 관련 모듈만 보면 된다.
- 확장성 증가: 새로운 기능을 별도 모듈로 추가하기 쉽다.

즉, v1.6.0은 기존의 복잡한 구조를 모듈화된 구조로 최적화하여, 실시간성·유지보수성·확장성을 모두 향상시켰다.

---

## 향후 확장 방향: RTOS 도입을 통한 시스템 고도화

v1.6.0에서 완성된 모듈화 구조는 while(1) 루프 기반의 순차적 처리 방식(Superloop)을 넘어,
실시간 운영체제(RTOS)를 도입하기 위한 훌륭한 기반이 되었다.
향후 시스템의 실시간성, 안정성, 확장성을 극대화하기 위해 FreeRTOS 도입을 목표로 한다.

### RTOS 도입의 필요성 및 기대 효과

현재 구조는 컨트롤러 입력(RF), DC/서보 모터 제어, CAN 거리 신호 수신 및 햅틱 제어 등 다양한 작업을 하나의 메인 루프에서 순차적으로 수행하고 있다.
이 방식은 간단하지만, 기능이 증가할수록 특정 작업이 다른 작업의 실행을 지연시키는 문제가 발생한다.
FreeRTOS와 같은 RTOS를 도입하면 이러한 문제를 해결하고 다음과 같은 효과를 기대할 수 있다:

- 실시간 응답성 확보 : 컨트롤러 입력 수신, CAN 거리 신호 반응, 햅틱 출력과 같은 시간 민감 작업을 각각 독립적인 태스크(Task)로 분리하고, 우선순위를 설정할 수 있다.
예를 들어, OLED 상태 표시와 같은 작업이 모터 제어나 무선 수신을 지연시키는 일을 방지할 수 있다.

- 시스템 확장성 향상 : 현재의 NRF24 수신 처리(RFHandler)나 모터 제어(MotorControl) 로직을 각각 InputTask, ControlTask 등으로 분리함으로써, 추후 GPS 수신, 배터리 모니터링, 데이터 로깅, 장애 감지 등 새로운 기능을 추가할 때 별도의 태스크만 정의하면 되므로 기존 코드 변경 없이 기능을 확장할 수 있다.

- 안정적인 통신 및 자원 보호 : 태스크 간 데이터 전달은 현재의 GetNewCommand() 방식 대신 Message Queue를 통해 처리할 수 있다. 예를 들어, InputTask가 수신한 컨트롤러 데이터를 큐에 넣고, MotorControlTask가 이를 큐에서 받아 처리하면 모듈 간 결합도를 낮추고 동기화를 보다 확실하게 유지할 수 있다.

또한 NRF24(SPI) 또는 SSD1306(I2C) 등 공유 자원 접근은 뮤텍스(Mutex)나 세마포(Semaphore)를 통해 보호하여 다중 태스크 환경에서도 안정적으로 하드웨어를 사용할 수 있다.

### 단계별 적용 계획
- 단계: 태스크 분리
    - `RFHandler` 로직을 `InputTask`로, `MotorControl` 및 RF 응답 처리를 `ControlTask` 또는 `CommTask`로 분리하여 독립적인 FreeRTOS 태스크로 전환한다.

- 2단계: 태스크 간 통신 구조 변경
    - `InputTask`는 수신한 조종 데이터를 구조체 형태로 메시지 큐에 전송하고, `CommTask`는 해당 큐로부터 데이터를 수신하여 모터 제어나 ACK 응답 처리에 활용한다.

- 3단계: 공유 자원 보호 적용 : SPI(NRF24), I2C(OLED) 등의 버스 자원은 Mutex로 보호하여,
여러 태스크가 동시에 접근할 경우에도 충돌이나 데이터 손상 없이 안정적인 운영을 보장한다.
