# Controller 부 파일 분할 및 코드 최적화 (v1.6.0)

## 프로젝트 목표

-   **목표**: Controller(조종기)의 단일 `main.c` 파일에 집중된 코드를 **통신(Communication)**과 **입력(Input)** 기능으로 모듈화하고, 코드 구조를 최적화하여 **유지보수성 및 재사용성**을 높이는 것을 목표로 합니다.

---

## 파일 분할 및 코드 최적화를 진행한 이유

기존 코드는 **`main.c` 단일 파일**에 통신, 센서 입력, 데이터 처리 등 모든 기능이 집중되어 있었습니다. 이로 인해 여러 기능이 전역 변수를 공유하게 되면서, 프로젝트의 규모가 커질수록 다음과 같은 잠재적인 문제점들이 발생할 수 있습니다.

###  **코드 추적 및 디버깅의 어려움**
-   전역 변수는 프로그램의 어느 함수나 인터럽트에서도 수정이 가능하므로, 특정 변수에 예기치 않은 값이 들어갔을 때 원인을 찾기 매우 어렵습니다. 이는 코드의 흐름을 파악하기 힘든 **스파게티 코드**의 원인이 됩니다.

###   **모듈의 재사용성 저하**
 -   특정 기능(예: 통신)을 담당하는 코드가 전역 변수에 의존하게 되면, 해당 모듈은 더 이상 독립적이지 않습니다. 이로 인해 다른 프로젝트에서 해당 기능만 분리하여 재사용하기가 어려워집니다.

###   **동시성 문제 및 데이터 손상 위험 (Race Condition)**
 -   메인 루프에서 여러 바이트로 구성된 전역 변수(예: 32비트 변수)를 읽는 도중, 우선순위가 높은 인터럽트가 발생하여 해당 변수의 값을 수정하면 데이터가 손상될 수 있습니다. 메인 루프는 인터럽트 발생 전후의 값이 섞인 **깨진 데이터(Corrupted Data)**를 읽게 되어, 예측 불가능한 오작동의 원인이 됩니다.

> 이러한 문제들을 해결하고 코드의 안정성과 구조적 품질을 높이고자, v1.6.0에서는 각 기능을 독립적인 파일로 분리하고 전역 변수 의존성을 줄이는 코드 최적화를 진행했습니다.

## 주요 변경 사항

### 1. 파일 분할 (모듈화)

기존 `main.c`의 역할을 분산시키고, 기능별 독립성을 확보하기 위해 아래와 같이 파일을 분할했습니다.

-   **`comm_handler.c/.h` (통신 핸들러)**
    -   **역할**: nRF24L01 통신과 관련된 모든 로직을 담당합니다.
    -   **주요 함수**: `Comm_Init()` (NRF 초기화), `Comm_PackAndTransmitData()` (데이터 패키징 및 전송), `Comm_HandleAckPayload()` (ACK 페이로드 처리) 등.

-   **`input_handler.c/.h` (입력 핸들러)**
    -   **역할**: 사용자의 물리적 입력을 처리하는 모든 로직을 담당합니다.
    -   **주요 함수**: `Input_Init()` (MPU6050 등 초기화), `Input_ReadSensors()` (자이로 센서 값 읽기), `Input_ProcessButtons()` (가속/브레이크/방향 스위치 상태 처리) 등.

-   **`main.c`의 역할 변경**
    -   **역할**: 초기화 이후, 메인 루프에서 각 모듈의 처리 함수를 순차적으로 호출하는 **중재자(Coordinator)** 역할을 수행합니다. 복잡한 로직은 모두 각 핸들러로 위임됩니다.

### 2. 코드 구조 최적화

파일 분할을 통해 아래와 같은 코드 구조 개선을 진행합니다.

-   **데이터 흐름 명확화**
    -   **내용**: 각 모듈의 데이터를 담는 구조체(예: `ControlInputData`)를 정의하고, `input_handler`에서 생성된 데이터 구조체를 `comm_handler`로 전달하는 방식으로 데이터 흐름을 명시적으로 만듭니다.
    -   **효과**: 전역 변수에 대한 의존성을 줄이고, 데이터 흐름 추적을 용이하게 합니다.

-   **캡슐화 및 책임 분리**
    -   **내용**: `main.c`는 더 이상 `memcpy`와 같은 데이터 패킹의 세부 사항이나 MPU6050의 레지스터 값을 알 필요가 없습니다. 각 모듈은 자신의 책임만 수행하고, 외부에는 필요한 인터페이스 함수만 노출합니다.
    -   **효과**: 모듈의 독립성이 높아져 개별적인 테스트 및 수정이 용이해집니다.

### 3. 주요 개선 사항: 통신 성능 최적화

v1.6.0에서는 조작의 실시간성을 높이기 위해 통신 프로토콜의 핵심 파라미터를 다음과 같이 개선했습니다.

-   **데이터 송신 속도 향상**: 기존 1Mbps에서 **2Mbps**로 변경하여 물리적인 전송 시간을 절반으로 단축했습니다.

-   **데이터 송신 주기 단축**: `HAL_Delay()`를 제거하고 비차단 로직을 적용하여, 20ms였던 전송 주기를 **1ms**로 단축시켜 조작 반응성을 크게 높였습니다.

-   **데이터 패킷 크기 축소**: 실제 사용하는 데이터만 포함하도록 패킷 구조를 재설계하여, 기존 32바이트에서 **8바이트**로 크기를 줄였습니다. 이는 전송 시간을 단축시키고 통신 효율을 높입니다.

이 세 가지 개선을 통해 **엔드 투 엔드(End-to-End) 지연 시간을 크게 단축**하여, 사용자가 거의 실시간에 가까운 조작감을 느낄 수 있도록 하였습니다.

## 주요 코드 설명

### `comm_handler.h`: 통신 모듈 인터페이스 정의
```c
/// comm_handler.h

#ifndef INC_COMM_HANDLER_H_
#define INC_COMM_HANDLER_H_

#include "main.h"

// ACK 페이로드 크기 정의
#define ACK_PAYLOAD_SIZE 2
#define PAYLOAD_SIZE 8

// 송신 결과 상태를 나타내는 열거형
typedef enum {
    COMM_OK,          // 별다른 이벤트 없음
    COMM_TX_SUCCESS,  // 송신 성공 및 ACK 수신
    COMM_TX_FAIL      // 송신 실패 (MAX_RT)
} CommStatus_t;

void CommHandler_Init(void);
void CommHandler_IrqCallback(void);
void CommHandler_Transmit(uint8_t* payload, uint8_t len);
CommStatus_t CommHandler_CheckStatus(uint8_t* ack_payload, uint8_t len);

#endif /* INC_COMM_HANDLER_H_ */

```

`comm_handler.h` 파일은 nRF24L01 무선 통신과 관련된 모든 기능을 **캡슐화**하고, 다른 모듈이 이를 사용할 수 있도록 **공용 인터페이스(Public Interface)**를 정의하는 헤더 파일입니다. `main.c`나 다른 모듈은 이 헤더 파일에 선언된 함수들만 호출하여 통신 기능을 수행하게 됩니다.

---
## `comm_handler.c`: 통신 모듈 구현
```c
// comm_handler.c

#include "comm_handler.h"
#include "NRF24.h"
#include "NRF24_reg_addresses.h"

static uint8_t tx_addr[5] = {0x45, 0x55, 0x67, 0x10, 0x21};
static volatile uint8_t nrf_irq_flag = 0;

void CommHandler_Init(void)
{
    csn_high();
    HAL_Delay(5);
    ce_low();
    nrf24_init();
    nrf24_stop_listen();
    nrf24_auto_ack_all(auto_ack);
    nrf24_en_ack_pld(enable);
    nrf24_dpl(disable);
    nrf24_set_crc(enable, _1byte);
    nrf24_tx_pwr(_0dbm);
    nrf24_data_rate(_2mbps);
    nrf24_set_channel(90);
    nrf24_set_addr_width(5);
    nrf24_auto_retr_delay(4);
    nrf24_auto_retr_limit(10);
    nrf24_open_tx_pipe(tx_addr);
    nrf24_open_rx_pipe(0, tx_addr);
    nrf24_pipe_pld_size(0, ACK_PAYLOAD_SIZE);
}

void CommHandler_IrqCallback(void)
{
    nrf_irq_flag = 1;
}

void CommHandler_Transmit(uint8_t* payload, uint8_t len)
{
    nrf24_transmit(payload, len);
}

CommStatus_t CommHandler_CheckStatus(uint8_t* ack_payload, uint8_t len)
{
    if (!nrf_irq_flag)
    {
        return COMM_OK;
    }
    nrf_irq_flag = 0;
    uint8_t status = nrf24_r_status();
    CommStatus_t result = COMM_OK;
    if (status & (1 << TX_DS))
    {
        if (nrf24_data_available())
        {
            nrf24_receive(ack_payload, len);
        }
        nrf24_clear_tx_ds();
        result = COMM_TX_SUCCESS;
    }
    else if (status & (1 << MAX_RT))
    {
        nrf24_flush_tx();
        nrf24_clear_max_rt();
        result = COMM_TX_FAIL;
    }
    return result;
}

```
`comm_handler.c` 파일은 `comm_handler.h`에 선언된 함수들을 실제로 구현하는 파일입니다. nRF24L01 드라이버 함수 호출과 통신 상태 관리를 담당하여, 다른 모듈로부터 저수준(low-level)의 하드웨어 제어를 완전히 숨기는 역할을 합니다.

---

### 주요 변수

-   **`static uint8_t tx_addr[5]`**: 통신에 사용될 5바이트 주소로, `static`으로 선언되어 `comm_handler.c` 파일 내부에서만 접근 가능합니다.
-   **`static volatile uint8_t nrf_irq_flag`**: IRQ 콜백 함수와 상태 확인 함수 간의 신호 역할을 하는 플래그입니다. `volatile` 키워드를 사용하여 최적화로 인한 오류를 방지합니다.

---

### 주요 함수 구현

-   **`CommHandler_Init()`**: nRF24L01 모듈의 데이터 속도를 **2Mbps**로 설정하고, ACK Payload 기능을 활성화하는 등 통신에 필요한 모든 레지스터를 설정합니다.

-   **`CommHandler_IrqCallback()`**: 외부의 `HAL_GPIO_EXTI_Callback`으로부터 호출되며, `nrf_irq_flag`를 1로 설정하는 단일 역할만 수행합니다.

-   **`CommHandler_Transmit()`**: 상위 모듈로부터 전달받은 데이터를 nRF24L01 드라이버의 `nrf24_transmit` 함수에 그대로 넘겨 전송을 시작시킵니다.

-   **`CommHandler_CheckStatus()`**: `main` 루프에서 주기적으로 호출되어 `nrf_irq_flag`의 상태를 확인합니다. 플래그가 설정되어 있으면, nRF24L01의 상태 레지스터를 읽어 **전송 성공(`TX_DS`)** 또는 **실패(`MAX_RT`)** 여부를 판단하고 그에 맞는 처리(ACK 수신, FIFO 플러시 등)를 한 뒤, 결과를 `CommStatus_t` 타입으로 반환합니다.
---

---
## `input_handler.h`: 사용자 입력 처리 모듈 인터페이스
```c
// input_handler.h

#ifndef INC_INPUT_HANDLER_H_
#define INC_INPUT_HANDLER_H_

#include "main.h"

// 방향 전송값 정의 (main.c에서 이곳으로 이동)
typedef enum {
    LOCKER_FORWARD = 1,
    LOCKER_BACKWARD = 0
} LockerDirection;

/**
 * @brief  입력 처리 모듈을 초기화합니다.
 */
void InputHandler_Init(void);

/**
 * @brief  GPIO 인터럽트 발생 시 호출될 콜백 함수입니다.
 * @param  GPIO_Pin: 인터럽트를 발생시킨 핀 번호
 */
void InputHandler_GpioCallback(uint16_t GPIO_Pin);

/**
 * @brief  타이머 인터럽트 발생 시 호출될 콜백 함수입니다.
 * 이 함수는 20ms마다 호출되는 것을 가정합니다.
 */
void InputHandler_TimerCallback(void);

/**
 * @brief  엑셀 버튼이 눌린 누적 시간을 ms 단위로 반환합니다.
 * @retval uint16_t: 엑셀 눌림 시간 (ms)
 */
uint16_t InputHandler_GetAccelMillis(void);

/**
 * @brief  브레이크 버튼이 눌린 누적 시간을 ms 단위로 반환합니다.
 * @retval uint16_t: 브레이크 눌림 시간 (ms)
 */
uint16_t InputHandler_GetBrakeMillis(void);

/**
 * @brief  현재 방향 스위치의 상태를 반환합니다.
 * @retval LockerDirection: 현재 방향 (FORWARD or BACKWARD)
 */
LockerDirection InputHandler_GetDirection(void);


#endif /* INC_INPUT_HANDLER_H_ */

```
`input_handler.h` 파일은 조종기의 버튼, 스위치 등 모든 물리적 사용자 입력을 처리하는 기능을 **캡슐화**하고, 외부 모듈이 사용할 수 있는 **공용 인터페이스**를 정의합니다. `main.c`는 이 헤더 파일에 선언된 `Get` 함수들을 통해 최종적으로 처리된 입력값만 가져다 사용하게 됩니다.  

---
## `input_handler.c`: 사용자 입력 처리 모듈 구현
```c
// input_handler.c

#include "input_handler.h"

// === 내부 전용 변수들 (static으로 선언하여 외부 접근 차단) ===
static volatile uint8_t accel_pressed = 0;
static volatile uint8_t brake_pressed = 0;
static volatile uint32_t accel_count = 0; // 20ms 단위 카운트
static volatile uint32_t brake_count = 0; // 20ms 단위 카운트

// === 함수 구현 ===

void InputHandler_Init(void)
{
    // 변수 초기화
    accel_pressed = 0;
    brake_pressed = 0;
    accel_count = 0;
    brake_count = 0;
}

void InputHandler_GpioCallback(uint16_t GPIO_Pin)
{
    // Accel 버튼 (PB0)
    if (GPIO_Pin == GPIO_PIN_0)
    {
        if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET) // 버튼 눌림
        {
            accel_pressed = 1;
            accel_count = 0; // 눌리는 순간 카운트 초기화
        }
        else // 버튼 떼짐
        {
            accel_pressed = 0;
            accel_count = 0; // 떼는 순간 카운트 초기화
        }
    }
    // Brake 버튼 (PB1)
    else if (GPIO_Pin == GPIO_PIN_1)
    {
        if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET) // 버튼 눌림
        {
            brake_pressed = 1;
            brake_count = 0;
        }
        else // 버튼 떼짐
        {
            brake_pressed = 0;
            brake_count = 0;
        }
    }
}

void InputHandler_TimerCallback(void)
{
    // 버튼이 눌려있는 동안 카운트 증가
    if (accel_pressed)
    {
        accel_count++;
    }
    if (brake_pressed)
    {
        brake_count++;
    }
}

uint16_t InputHandler_GetAccelMillis(void)
{
    // Race Condition을 피하기 위해 잠시 인터럽트를 비활성화하고 값을 읽음
    uint32_t count_snapshot;
    __disable_irq();
    count_snapshot = accel_count;
    __enable_irq();

    return (uint16_t)(count_snapshot * 20);
}

uint16_t InputHandler_GetBrakeMillis(void)
{
    // Race Condition을 피하기 위해 잠시 인터럽트를 비활성화하고 값을 읽음
    uint32_t count_snapshot;
    __disable_irq();
    count_snapshot = brake_count;
    __enable_irq();

    return (uint16_t)(count_snapshot * 20);
}

LockerDirection InputHandler_GetDirection(void)
{
    // 락커 스위치 판별 (PB9: FORWARD)
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_9) == GPIO_PIN_RESET)
    {
        return LOCKER_FORWARD;
    }
    else
    {
        return LOCKER_BACKWARD;
    }
}

```
`input_handler.c` 파일은 `input_handler.h`에 선언된 함수들을 실제로 구현하는 파일입니다. 버튼 및 스위치의 상태를 내부적으로 관리하고, 최종적으로 처리된 값을 외부에 제공하는 역할을 합니다.
### 주요 변수 및 동작 방식

-   **내부 상태 변수**: 버튼의 눌림 상태(`_pressed`)와 눌린 시간(`_count`)을 저장하는 변수들은 `static`으로 선언되어 외부 모듈로부터 완벽히 격리됩니다. `volatile` 키워드를 통해 인터럽트와 메인 루프 간의 데이터 공유 시 발생할 수 있는 컴파일러 최적화 문제를 방지합니다.

-   **동작 원리**:
    1.  `InputHandler_GpioCallback`이 버튼의 **눌림/떼짐 이벤트**를 감지합니다.
    2.  `InputHandler_TimerCallback`이 버튼이 **눌려있는 동안 시간**을 계속 측정합니다.
    3.  `main`에서는 `InputHandler_Get...` 함수들을 호출하여, 가공된 최종 결과값만 얻습니다.

---

### 주요 함수 구현

-   **`InputHandler_Init()`**: 모듈이 사용하는 모든 내부 `static` 변수들을 0으로 안전하게 초기화합니다.

-   **`InputHandler_GpioCallback()`**: 인자로 받은 `GPIO_Pin` 번호를 확인하여, 가속 또는 브레이크 버튼의 눌림/떼짐 상태에 따라 내부 `_pressed` 플래그를 설정하고 `_count` 변수를 0으로 리셋합니다.

-   **`InputHandler_TimerCallback()`**: 주기적인 타이머에 의해 호출되며, `_pressed` 플래그가 참일 경우에만 해당하는 `_count` 변수를 1씩 증가시켜 눌린 시간을 누적합니다.

-   **`InputHandler_Get...()` 함수들**: 외부 모듈에 최종 입력값을 제공하는 인터페이스입니다.
    -   특히 `GetAccelMillis`와 `GetBrakeMillis` 함수는 32비트 변수인 `_count`를 읽는 도중 인터럽트가 발생하여 값이 깨지는 **Race Condition**을 방지하기 위해, `__disable_irq()`와 `__enable_irq()`를 사용하여 **임계 영역(Critical Section)** 내에서 안전하게 값을 복사한 후 계산하여 반환합니다.

---
## `main.c`: 모듈 중재자(Coordinator) 역할 변경
파일 분할 및 코드 최적화 이후, `main.c`는 더 이상 모든 저수준(low-level) 로직을 수행하지 않습니다. 대신 각 모듈(`input_handler`, `comm_handler`)을 총괄하고, 어플리케이션의 전체 흐름을 관리하는 **중재자(Coordinator)** 역할을 담당하게 됩니다.  

---
### 1. `main()` 함수의 역할 변화

기존 `main()` 함수 내에서 직접 수행하던 센서 데이터 읽기, 데이터 패킷 구성, 상태 레지스터 확인 등의 복잡한 로직이 모두 각 핸들러 함수 호출로 변경되었습니다. 이로 인해 `main()` 함수의 `while` 루프는 **"입력값으로 패킷을 만들어 전송하고, 결과를 확인한다"**는 명확하고 단순한 구조를 갖게 되었습니다.

```c
while (1)
{
    uint32_t now = HAL_GetTick();

    if (now - lastTransmitTick >= TRANSMIT_INTERVAL_MS)
    {
        lastTransmitTick = now;

        // 1. 센서 값 읽기 (내부 헬퍼 함수)
        float roll = App_GetRollAngle();

        // 2. 전송 패킷 생성 (내부 헬퍼 함수)
        App_BuildPacket(tx_packet, roll);

        // 3. 데이터 전송 (통신 핸들러에 위임)
        CommHandler_Transmit(tx_packet, PAYLOAD_SIZE);

        // 4. 통신 결과 확인 및 처리 (통신 핸들러에 위임)
        CommStatus_t status = CommHandler_CheckStatus(ack_packet, ACK_PAYLOAD_SIZE);
        if (status == COMM_TX_SUCCESS)
        {
            App_HandleAckPayload(ack_packet);
        }
        else if (status == COMM_TX_FAIL)
        {
            // TODO: 통신 실패 시 처리 로직
        }
    }
}
```
---
### 2. 내부 헬퍼 함수 (Static Function) 도입
main.c의 가독성을 해치던 상세 구현 로직들은 파일 내에서만 접근 가능한 static 함수로 분리되었습니다.

- App_BuildPacket(): input_handler로부터 각종 입력값을 가져오고, memcpy를 통해 전송 규격에 맞는   
데이터 패킷을 구성하는 역할을 전담합니다. main() 함수는 더 이상 패킷의 상세 구조를 알 필요가 없습니다.
```c
static void App_BuildPacket(uint8_t* packet_buffer, float roll_angle)
{
    memset(packet_buffer, 0, PAYLOAD_SIZE);
    packet_buffer[0] = 1; // ID

    // Roll 값 인코딩
    int16_t roll_encoded = (int16_t)(roll_angle * 100.0f);
    memcpy(&packet_buffer[1], &roll_encoded, sizeof(int16_t));

    // 버튼 입력 시간 가져오기 (InputHandler에 위임)
    uint16_t accel_ms = InputHandler_GetAccelMillis();
    uint16_t brake_ms = InputHandler_GetBrakeMillis();
    memcpy(&packet_buffer[3], &accel_ms, sizeof(uint16_t));
    memcpy(&packet_buffer[5], &brake_ms, sizeof(uint16_t));

    // 방향 정보 가져오기 (InputHandler에 위임)
    packet_buffer[7] = InputHandler_GetDirection();
}
```
---
### 3. 콜백 함수의 역할 위임 (Delegation)
HAL_GPIO_EXTI_Callback과 HAL_TIM_PeriodElapsedCallback 같은 HAL 드라이버 콜백 함수들은 더 이상 자체적으로 로직을 처리하지 않습니다. 대신, 인터럽트의 종류를 파악하여 해당 이벤트를 처리해야 할 적절한 핸들러 모듈의 콜백 함수를 호출해주는 단순 중개(Dispatcher) 역할만 수행합니다.
```c
// 콜백 함수들은 각 핸들러에게 작업을 위임
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    // nRF IRQ 핀이면 CommHandler 호출
    if (GPIO_Pin == GPIO_PIN_3)
    {
        CommHandler_IrqCallback();
        return;
    }
    // 그 외 버튼 핀이면 InputHandler 호출
    InputHandler_GpioCallback(GPIO_Pin);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM2)
    {
        InputHandler_TimerCallback();
    }
}
```
---
# 향후 확장 방향: RTOS 도입을 통한 시스템 고도화

v1.6.0에서 완성된 **모듈화 구조**는 `while(1)` 루프 기반의 순차적 처리 방식(Superloop)을 넘어,   
**실시간 운영체제(RTOS)**
를 도입하기 위한 훌륭한 기반이 됩니다. 향후 시스템의 안정성과 확장성을 극대화하기 위해 FreeRTOS와 같은 RTOS를 적용하는 것을 목표로 합니다.

---

### RTOS 도입의 필요성 및 기대 효과

기존의 `main` 루프 방식은 기능이 추가될수록 특정 로직이 다른 로직의 실행 시간을 지연시켜 전체적인 반응성에 영향을 줄 수 있습니다. RTOS를 도입하면 이러한 문제를 해결하고 다음과 같은 효과를 얻을 수 있습니다.

-   **실시간성 및 응답성 보장**
    -   각 기능 모듈을 **독립적인 태스크(Task)**로 분리하고, 우선순위를 할당할 수 있습니다. 이를 통해 조종기 입력 처리나 무선 통신과 같은 **중요 작업이 다른 저순위 작업(예: OLED 디스플레이 업데이트)에 의해 지연되는 현상을 원천적으로 방지**할 수 있습니다.

-   **시스템 확장성의 극대화**
    -   현재의 `input_handler`, `comm_handler`를 각각 별개의 태스크로 변환할 수 있습니다. 향후 데이터 로깅, GPS 수신, 복잡한 UI 처리 등 새로운 기능을 추가할 때, 기존 코드에 영향을 주지 않고 **새로운 태스크만 추가**하면 되므로 시스템 확장이 매우 용이해집니다.

-   **안정적인 데이터 통신 및 자원 관리**
    -   태스크 간의 데이터 공유 시, 현재의 `Get...()` 함수 방식 대신 **메시지 큐(Message Queue)**를 사용할 수 있습니다. `input_handler` 태스크는 처리된 데이터를 큐에 넣고, `comm_handler` 태스크는 큐에서 데이터를 꺼내 사용함으로써 두 태스크의 동작을 완벽히 분리(Decoupling)할 수 있습니다.
    -   SPI나 I2C와 같은 공유 자원은 **뮤텍스(Mutex)**나 **세마포(Semaphore)**를 통해 보호하여, 여러 태스크가 동시에 접근할 때 발생하는 충돌 및 데이터 손상 문제를 안정적으로 해결할 수 있습니다.

### 단계별 적용 계획

1.  **1단계: 태스크 분리**
    -   `input_handler`의 로직을 `InputTask`로, `comm_handler`의 로직을 `CommTask`로 각각 분리하여 독립적인 태스크로 만듭니다.

2.  **2단계: 태스크 간 통신 변경**
    -   두 태스크 간의 데이터 전달을 위해 **메시지 큐**를 생성합니다. `InputTask`는 처리된 조종 데이터를 이 큐에 보내고, `CommTask`는 큐로부터 데이터를 받아 전송합니다.

3.  **3단계: 공유 자원 보호**
    -   SPI 통신이 필요한 `CommTask`가 SPI 버스를 사용하기 전에 **뮤텍스**를 획득(Take)하고, 사용 후 반납(Give)하도록 하여 하드웨어 자원을 안전하게 관리합니다.
