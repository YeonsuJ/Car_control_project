# M3보드 기반 RF 송수신 모터 제어 통합 구현 (v1.0.0)

## ⚠️🛠️ 문제 해결 및 개선/확장

### 문제상황
M3 보드 간의 RF 통신은 정상적으로 동작하였으나, 핸들부(Unit_Controller)와 차량 모터 제어부(Unit_Car_Central) 간 RF 통신을 위해 STM32F103C8T6(M3 보드)와 기존에 Unit_Car_Central(모터 제어부)에 사용했던 STM32F446RE(M4 보드)를 연동하는 과정에서 문제가 발생했다.

👉 자세한 문제 상황 : [수신부 보드전환 후 RF 수신 실패 문제](../troubleshooting/M4_RF_Communication_Failure.md)

해결 : 이에 따라 프로젝트의 원활한 진행과 하드웨어 비용 절감, 그리고 현재 CAN_Central 보드가 모터 구동과 SPI 기반 RF 통신만을 담당하고 있다는 점을 고려할 때, M4보드보다 M3 보드가 보다 적합하다고 판단하였다.

향후 기능 향상 및 확장이 필요한 경우에 한해 Car_Central 보드를 M4 보드로 다시 전환하는 것을 보완 계획으로 설정하였다.

---

## 🔌 하드웨어 연결
※ 송신부(Tx)는 [M3_RF_Communication.md](./M3_RF_Communication.md)와 동일

<img src="../wiring_diagram/m3_motorctrl.png" alt="RF 수신부 모터 구동 배선도" width="500"/>



---

## ⚙️ STM32CubeMX 설정
※ 송신부(Tx)는 [M3_RF_Communication.md](./M3_RF_Communication.md)와 동일

> 이전 개발일지 참고 :<br>
[Dc_Motor.md](./Dc_Motor.md)<br>
[Servo_Motor.md](./Servo_Motor.md)

1. DC모터 PWM_ENA
- pb8 (tim4_ch3) -> pa11 (tim1_ch4)
- pwm generation ch4
- prescaler : 36-1
- Counter Period : 999

2. DC모터 Encoder
- combined channels > encoder mode
- pa6 (tim3_ch1) : encoderA -> pb6 (tim4_ch1) : encoderA
- pa7 (tim3_ch2) : encoderB -> pb7 (tim4_ch2) : encoderB
- encoder mode TI1 adn TI2
- prescaler : 0
- Counter period(ARR) : 65535 or 0xFFFF (엔코더 overflow 방지)
- Counter Mode : UP
- IC1 Polarity: Rising Edge
- IC1 Selection: Direct TI
- IC1 Prescaler: No division (1번마다 1번 인식 = 모든 엣지를 다 인식함)
- IC1 Filter: 10 (노이즈가 심하면 값을 올려줘야함)
- (IC2 항목도 동일하게 설정)

3. DC모터 방향 설정
- pb4 (gpio_output) : l298n_in1 -> pa0 (gpio_output) :l298n_in1
- pb5 (gpio_output) : l298n_in2 -> pa1 (gpio_output) :l298n_in2

---

## 💻 동작 코드
※ 기존 송신부(Tx)의 로직과 수신부(Rx)의 로직은 [M3_RF_Communication.md](./M3_RF_Communication.md)와 동일

### 추가된 수신부(Rx) 모터 동작 로직
```c
while(1)
{
    // 서보모터, DC모터 제어 로직 함수 분리
    Control_Servo(roll);
    Control_DC_Motor(accel_ms, brake_ms);
}

// 서보 모터 제어 함수
void Control_Servo(float roll)
{
	if (roll < -90.0f) roll = -90.0f;
	if (roll >  90.0f) roll = 90.0f;

	// roll [-90 ~ 90] → angle [0 ~ 180]
	float angle = roll + 90.0f;

	// servo pwm : 우회전최대 = 1200, 중립 = 1550, 좌회전최대 = 1900
	uint16_t pwm_servo = (uint16_t)(1200 + (angle / 180.0f) * (1900-1200));

	// 출력 제한 (안정성 보장)
	if (pwm_servo < 1200) pwm_servo = 1200;
	if (pwm_servo > 1900) pwm_servo = 1900;

	__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, pwm_servo);
}

// DC 모터 제어 함수
void Control_DC_Motor(uint16_t accel_ms, uint16_t brake_ms)
{
    static int16_t duty = 0;  // PWM duty값 (static으로 유지)
    const int16_t accel_step = 10;     // 가속 증가폭
    const int16_t brake_step = 30;     // 브레이크 감소폭
    const int16_t max_duty = 1000;     // 최대 duty (ARR와 맞춰야 함)

    // 1. 브레이크 우선 처리
    if (brake_ms > 0)
    {
        duty -= brake_step;
    }
    // 2. 가속 입력 처리
    else if (accel_ms > 0)
    {
        if (duty == 0)
            duty = 200;  // Deadzone 극복을 위한 초기값 설정

        duty += accel_step;
    }
    // 3. 엑셀에서 발 뗀 상태 → 감속
    else if (accel_ms == 0)
    {
        duty -= accel_step;
    }

    // 4. PWM duty 범위 제한
    if (duty < 0)
        duty = 0;
    if (duty > max_duty)
        duty = max_duty;

    // 5. PWM 출력 적용 (htim1, TIM_CHANNEL_4 사용)
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_4, duty);
}


```

### 📺 동작 영상
[RF 송/수신 acc, brk, roll 값 기반 서보/DC모터 동작 테스트 링크](https://www.youtube.com/watch?v=gWtgOxEqD58)

---

## 💡 향후 확장 및 개선 아이디어
- v1.1.0 업데이트 (encoder 기반 rpm 디스플레이 및 로커스위치로 전/후진 기어변속 기능 추가)
- FreeRTOS를 도입하여 서보모터 제어, DC 모터 제어, RF 수신 기능을 각각 태스크로 분리하여 병렬 처리 구조 구현
- 차량 RC 테스트 결과 조향범위와 dc모터의 출력 로직 수정 필요