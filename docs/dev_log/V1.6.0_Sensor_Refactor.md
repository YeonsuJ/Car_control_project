# Sensor 부 파일 분할 및 코드 최적화, CAN 개선 (v1.6.0)

## 파일 분할 및 코드 최적화 목적

기존 sensor_v1.5.0은 모든 기능이 main.c 하나에 집중되어 있어 코드 복잡도가 높고 유지보수가 어려웠다. 특히, 초음파 센서 제어 로직과 CAN 메시지 송신 처리가 하나의 루프에서 직접 처리되며, 코드의 가독성 저하, 기능별 독립성 부족, 디버깅 어려움 등의 문제가 존재했다.
이를 해결하기 위해 sensor_v1.6.0에서는 다음과 같은 방식으로 기능별 모듈화 및 파일 분할을 수행하였다.

---

## 주요 변경 사항

### 1. 파일 분할 (모듈화)

기존 `main.c`의 역할을 분산시키고, 기능별 독립성을 확보하기 위해 아래와 같이 파일을 분할함

- `can_handler.c/.h` (CAN 통신 핸들러)
    - 역할: CAN 초기화 및 거리 조건에 따른 송신 데이터를 설정하고, 이를 CAN 메시지로 전송함. 송신 메시지는 다른 노드에서 위험 감지를 판단할 수 있도록 TxData[0]에 1 또는 0을 설정해 전송.

    - 주요 함수 : `CAN_tx_Init()` : CAN 시작 및 송신 헤더 설정, `CAN_Send()` : 설정된 데이터를 CAN 메시지로 전송

- `ultrasonic.c/.h` (초음파 센서 핸들러)
    - 역할 : 전방(PA9 트리거, PB6 에코) 및 후방(PA8 트리거, PB5 에코) 초음파 센서의 거리 측정을 담당함. 타이머 입력 캡처 인터럽트를 통해 Echo 신호를 측정하고, 거리값을 계산하여 전역 변수로 저장함.
    
    주요 함수 : `Ultrasonic_Init()` : 타이머 및 인터럽트 초기화, `Ultrasonic_Trigger()` : 두 초음파 센서에 트리거 신호 발생, `HAL_TIM_IC_CaptureCallback()` : 입력 캡처 인터럽트 기반 거리 측정 수행

- `main.c`의 역할 변경
    - 역할 : 시스템 초기화 이후 main() 루프에서 주기적으로 초음파 트리거를 발생시키고, 측정된 전방/후방 거리 값을 기반으로 위험 감지 여부를 판단하여 CAN 메시지를 송신함. 직접적인 거리 측정 로직이나 CAN 송신 코드는 모두 ultrasonic.c 및 can_handler.c에 위임되며, main.c는 전반적인 흐름을 조율하는 중재자(Coordinator) 역할을 수행함.

    - 주요 처리 로직:
        - 100ms 주기로 거리 측정 트리거
        - 전방 또는 후방 거리 중 하나라도 10cm 이하일 경우 위험 상태 전송 (TxData[0] = 1), 그렇지 않으면 안전 상태 전송 (TxData[0] = 0)

### 2. 코드 구조 최적화

파일 분할을 통해 아래와 같은 코드 구조 개선을 진행하였다.

#### 데이터 흐름 명확화
- 내용: 
    - 초음파 센서에서 측정된 거리 값은 ultrasonic.c 내부에서 distance_front, distance_rear 전역 변수에 저장된다.
    - main.c에서는 해당 거리 값을 기준으로 위험 여부를 판단하고, 이를 TxData[0]에 반영한 후 CAN_Send() 함수를 통해 메시지를 송신한다.
    - TxData[0]의 값(1: 위험, 0: 안전)은 수신 노드에서 햅틱 피드백 또는 OLED 출력 등에 활용된다.

- 효과 : 
    - 거리 측정 → 거리 판단 → CAN 전송이라는 단방향 흐름이 명확히 유지되며, 각 단계에서의 데이터 사용 위치가 명확하다.
    - 전역 변수의 혼용을 최소화하고, 각 모듈이 정의된 데이터 흐름만 처리하게 하여 디버깅과 추적이 용이해짐

#### 캡슐화 및 책임 분리
- 내용 : 
    - main.c는 더 이상 거리 측정 세부 처리(IC 캡처, 타이머 설정)나 CAN 전송 데이터 구성 세부 사항을 직접 다루지 않는다.
    - ultrasonic.c는 거리 측정만, can_handler.c는 송신 메시지 처리만 담당한다.
    - main.c는 타 주기적 로직의 흐름 제어만 담당하며, 하드웨어 세부 동작은 각 모듈에 위임됨
        - 예: Ultrasonic_Trigger()는 트리거 신호만 발생시킴 (내부 딜레이 포함)
        - CAN_Send()는 설정된 TxData[]를 이용해 송신만 수행하며, 메시지 구성은 main.c에서 판단하여 설정

- 효과 :
    - 각 모듈이 명확한 책임을 가지므로 모듈 간 결합도가 낮아지고,
    - 기능 추가/수정 시 다른 파일에 영향을 거의 주지 않음
    - 단위 테스트 또는 모듈 단독 테스트 수행이 쉬워져 유지보수성 및 확장성이 향상됨 

### 3. 주요 개선 사항: 통신 성능 최적화

sensor_v1.6.0에서는 초음파 거리 감지 결과를 보다 빠르고 안정적으로 전송하기 위해 CAN 통신 성능 최적화를 중점적으로 수행하였다. 이를 통해 거리 정보의 실시간 전송이 가능해졌으며, 햅틱 반응 등 응답성이 요구되는 기능에서도 End-to-End 지연 시간을 최소화하였다.

#### CAN 통신 최적화
1. 보드레이트 향상
    - CAN의 Prescaler 값을 72 → 18로 조정하여, 125kbps → 500kbps의 고속 통신 환경으로 개선함.
    - 초음파 센서 측정 후 거리 정보 전송 딜레이가 크게 감소, 햅틱 등 수신 노드의 반응 시간이 단축됨.

2. 자동 재전송 및 오류 복구 기능 활성화
    - AutoBusOff, AutoRetransmission 기능을 활성화하여 일시적 충돌이나 에러 상황에서도 자동으로 복구 및 재송신이 수행되도록 설정.
    - 안정적인 CAN 통신 유지로, 거리 정보가 누락되지 않으며 실시간성을 보장함.

3. 송신 데이터 패킷 구조 단순화 및 데이터 길이 최적화
    - 거리 정보는 위험(1) / 안전(0)의 1비트 신호만 전달되므로, TxData[0] 하나의 바이트만 사용
    - TxHeader.DLC 값을 8 → 1로 변경하여 실제 전송 데이터 길이와 일치시킴
    - TxData[] 배열 크기를 8 → 1로 축소하여 메모리 할당 범위 정비

#### 개선 효과

- End-to-End 지연 시간 최소화 : 초음파 트리거 → 거리 측정 → CAN 전송 → 수신 노드 반응까지의 전체 흐름이 최적화되어, 거리 변화에 대한 시스템 반응이 즉각적으로 동작함

- 시스템 안정성 향상 : 일시적인 에러나 노이즈 상황에서도 자동 복구 기능으로 연속적인 거리 상태 전송이 보장되며, 수신 누락 가능성이 현저히 감소

- 확장성 기반 마련 : 고속 CAN 설정을 통해 이후 다중 거리 센서, 다양한 경고 장치, 여러 수신 노드가 존재하는 구조로의 확장도 무리 없이 대응 가능

- 송신 데이터 패킷 구조 최적화 : 불필요한 데이터를 제거하고 전송 길이를 최소화함으로써 패킷 전송 속도가 향상되고, CAN 버스의 대역폭 점유율이 감소하여 전체 통신 효율이 높아짐. 또한 수신 노드의 반응 속도가 빨라지고, TxData 배열 크기 축소를 통해 메모리 사용량도 줄어드는 등 시스템 자원의 효율성이 전반적으로 개선

---

## 주요 코드 설명

### `can_handler.h`: CAN 통신 모듈 인터페이스 정의
```c
#ifndef INC_CAN_TX_HANDLER_H_
#define INC_CAN_TX_HANDLER_H_

#include "main.h"

extern CAN_TxHeaderTypeDef TxHeader;
extern uint32_t TxMailbox;
extern uint8_t TxData[1];

void CAN_tx_Init(void);   /* HAL_CAN_Start + 헤더 설정 */
void CAN_Send(void);   /* TxData[0] 전송 */

#endif /* INC_CAN_TX_HANDLER_H_ */
```
- CAN_tx_Init()
    - CAN 통신을 시작하고, 송신용 TxHeader를 설정 (표준 ID, Data Frame, DLC = 8)
    - 메시지 전송을 위한 기본 설정 함수

- CAN_Send()
    - TxData[] 배열에 설정된 데이터를 CAN 메시지로 전송
    - 센서부에서는 TxData[0]에 위험 여부(1 또는 0)를 설정하여 전송함

- extern 변수
    - TxHeader, TxMailbox, TxData[]를 다른 모듈(main.c 등)에서 접근할 수 있도록 외부 선언 처리

### `can_handler.c`: CAN 통신 모듈 구현
```c
#include "can_handler.h"
#include "can.h"

CAN_TxHeaderTypeDef TxHeader;
uint32_t TxMailbox;
uint8_t TxData[1]; // 외부 접근을 위해 전역 선언


void CAN_tx_Init(void)
{
	HAL_CAN_Start(&hcan);

	TxHeader.DLC = 1;  // data length : 1바이트만 전송
	TxHeader.IDE = CAN_ID_STD;
	TxHeader.RTR = CAN_RTR_DATA;
	TxHeader.StdId = 0x6A5;  // ID can be between Hex1 and Hex7FF (1-2047 decimal)
}

void CAN_Send(void)
{
	HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox);
}
```

- 전역 변수 선언
    - `TxHeader`: 송신 메시지의 헤더 정보(ID, 데이터 길이, Frame 유형 등)
    - `TxMailbox`: 메시지 전송을 위한 Mailbox 식별자
    - `TxData[1]`: 전송할 데이터 배열, 현재는 1바이트(위험 여부만 전달)

- `CAN_tx_Init()` 함수
    - CAN 통신을 시작하고(HAL_CAN_Start), 전송 메시지의 기본 헤더를 설정
    - 송신 ID는 0x6A5로 고정, 데이터 프레임이며 길이는 1바이트로 구성

- `CAN_Send()` 함수
    - `TxData[0]`에 담긴 데이터를 CAN 메시지로 전송
    - 전송 시 설정된 TxHeader 정보와 함께 CAN Mailbox에 추가됨
    - 센서 노드에서는 초음파 센서 판별 결과(1: 위험, 0: 안전)를 이 배열에 기록 후 호출

### `ultrasonic.h`: 초음파센서 모듈 인터페이스 정의
```c
#ifndef INC_ULTRASONIC_H_
#define INC_ULTRASONIC_H_

#include "main.h"

// 다른 파일(main.c 등)에서 사용할 수 있게 extern 선언
extern volatile uint32_t distance_front;
extern volatile uint32_t distance_rear;

void delay_us(uint16_t us);
void Ultrasonic_Init(void);
void Ultrasonic_Trigger(void);

#endif /* INC_ULTRASONIC_H_ */
```

- 거리값 변수는 extern volatile로 선언되어 다른 모듈에서 공유 가능
- delay_us()는 정확한 트리거 펄스 생성 및 시간 측정을 위한 핵심 유틸리티 함수
- Ultrasonic_Init(), Ultrasonic_Trigger()는 센서 사용을 위한 초기화 및 트리거 인터페이스 제공

### `rf_handler.c`: RF 통신 모듈 구현
```c
#include "ultrasonic.h"
#include "tim.h"

/* 외부 핸들 */
extern TIM_HandleTypeDef htim2;
extern TIM_HandleTypeDef htim4;

// 전역변수
volatile uint32_t ic_val1_front = 0;
volatile uint32_t ic_val2_front = 0;
volatile uint8_t is_first_captured_front = 0;
volatile uint32_t distance_front = 0;

volatile uint32_t ic_val1_rear = 0;
volatile uint32_t ic_val2_rear = 0;
volatile uint8_t is_first_captured_rear = 0;
volatile uint32_t distance_rear = 0;

// tim2를 delay로 사용
void delay_us(uint16_t us)
{
  __HAL_TIM_SET_COUNTER(&htim2, 0);
  while (__HAL_TIM_GET_COUNTER(&htim2) < us);
}

// 모듈 초기화
void Ultrasonic_Init(void)
{
	HAL_TIM_Base_Start(&htim2);  // 타이머 카운터만 시작
	HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_1);
	HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_2);
}

void Ultrasonic_Trigger(void)
{
	// 1) 전방 트리거
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET);
	delay_us(10);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET);

	// 2) 후방 트리거
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
	delay_us(10);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
}

// input 캡처 콜백 함수
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM4)
  {
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)  // 전방 Echo
    {
      if (is_first_captured_front == 0)
      {
        ic_val1_front = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
        is_first_captured_front = 1;
      }
      else
      {
        ic_val2_front = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
        __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
        uint32_t diff = (ic_val2_front > ic_val1_front) ? (ic_val2_front - ic_val1_front) : (0xFFFF - ic_val1_front + ic_val2_front);
        distance_front = (diff * 0.0343f) / 2.0f;
        is_first_captured_front = 0;
        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
      }
    }

    else if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)  // 후방 Echo ← 수정됨
    {
      if (is_first_captured_rear == 0)
      {
        ic_val1_rear = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING);
        is_first_captured_rear = 1;
      }
      else
      {
        ic_val2_rear = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_RISING);
        __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
        uint32_t diff = (ic_val2_rear > ic_val1_rear) ? (ic_val2_rear - ic_val1_rear) : (0xFFFF - ic_val1_rear + ic_val2_rear);
        distance_rear = (diff * 0.0343f) / 2.0f;
        is_first_captured_rear = 0;
        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
      }
    }
  }
}
```
- 전역변수 
    - 전방/후방 초음파 센서 각각에 대해 측정값 2개(IC1, IC2)와 캡처 상태 플래그 사용
    - 거리 계산 결과는 각각 distance_front, distance_rear에 저장됨
    - volatile: 인터럽트에 의해 변경되므로 최적화 방지

- `delay_us()` 함수
    - 타이머(TIM2)의 카운터를 사용한 마이크로초 지연 함수
    - Trigger 핀에 정확한 10us 펄스를 생성하기 위해 사용됨

- `Ultrasonic_Init()` 함수
    - TIM2: delay용 타이머 → 기본 카운터만 시작
    - TIM4: Echo 신호를 측정할 타이머 → CH1(전방), CH2(후방) 인터럽트 입력 캡처 시작

- `Ultrasonic_Trigger()` 함수
    - 전방(PA9), 후방(PA8) Trigger 핀에 10us HIGH 펄스를 각각 출력
    - 초음파 센서가 Echo 신호를 반환할 수 있도록 유도

- `HAL_TIM_IC_CaptureCallback()` 함수
    - Echo 핀에서 수신된 신호의 Rising/Falling 엣지를 인터럽트로 감지하고 처리
    - 전방: TIM_CHANNEL_1, 후방: TIM_CHANNEL_2
    - 작동 순서:
    1. Rising Edge: 시작 시간(ic_val1_*) 저장, 이후 Falling으로 폴라리티 전환
    2. Falling Edge: 끝 시간(ic_val2_*) 저장 후 다시 Rising으로 설정
    3. 시간 차(diff)를 기반으로 거리 계산:
        ```c
        //왕복이므로 2로 나눔
        // 초음파 속도: 343m/s → 0.0343 cm/us
        distance = (diff * 0.0343f) / 2.0f; 
        ```
    4. 인터럽트 잠시 끈 후 다시 활성화 (DISABLE_IT → ENABLE_IT)

### `main.c` 의 개선

기존(v1.5.0)의 main.c는 초음파 센서 제어, 거리 계산, 트리거 출력, CAN 송신 설정 및 전송까지 모든 로직이 하나의 파일에 집중되어 있었다.

각각의 동작이 main 함수 내에서 직접 수행되어 복잡하고 비직관적이며, 수정이나 확장 시 전체 로직에 영향을 주는 구조였다.

v1.6.0에서는 기능을 명확히 구분하여 모듈화(MVC 스타일 분리) 하였으며, main.c는 단순히 시스템 흐름을 제어하는 역할로만 구성되었다:

```c
while (1)
{
    if (HAL_GetTick() - prev_tick >= 100)
    {
        prev_tick = HAL_GetTick();

        Ultrasonic_Trigger();

        TxData[0] = (distance_front <= 10 || distance_rear <= 10) ? 1 : 0;

        CAN_Send();
    }
}

```

- Trigger 출력, 거리 계산은 ultrasonic.c에서 처리
- CAN 헤더 구성 및 송신은 can_handler.c에서 수행
- main은 단지 주기 체크 + 상태 확인 + 전송 명령만 담당

이로 인해 얻는 이점은 다음과 같다:
- 가독성 향상: main 함수는 시스템의 흐름만 담당하며, 각 기능은 독립된 모듈로 분리되어 로직이 명확하고 직관적으로 읽을 수 있다.

- 유지보수 용이: 오류 발생 시 해당 기능의 모듈만 점검하면 되므로, 디버깅 시간이 단축되고 안정성이 높아진다.

- 확장성 증가: 새로운 센서, 통신 방식(CAN 외 RF 등), 또는 기능 추가 시 기존 구조를 건드리지 않고 새로운 모듈만 추가하면 되므로, 프로젝트가 커져도 구조를 유지할 수 있다.

- 재사용성 강화: ultrasonic.c, can_handler.c 등은 다른 프로젝트에서도 그대로 활용 가능하여 개발 효율이 증가한다.

- 실시간성 확보 준비: 로직이 분리되어 있으므로, FreeRTOS 같은 RTOS 환경으로 쉽게 이식할 수 있는 기반이 된다.

이러한 개선은 단순한 코드 정리를 넘어 시스템의 품질과 확장 가능성 전반을 끌어올리는 핵심 구조적 변화라 할 수 있다.

---

## 향후 확장 방향: RTOS 도입을 통한 시스템 고도화

v1.6.0에서는 초음파 센서 모듈화, CAN 송신 처리의 분리, main.c의 단순화를 통해 while(1) 기반의 순차 처리(Superloop) 구조를 태스크 기반 처리로 전환할 수 있는 기반을 마련하였다.

앞으로 시스템의 실시간성, 확장성, 안정성을 향상시키기 위해 FreeRTOS 도입을 목표로 한다.

### RTOS 도입의 필요성 및 기대 효과
현재 구조는 다음과 같은 순차 흐름을 따른다:
1. 일정 주기로 초음파 트리거 신호 출력
2. 입력 캡처 인터럽트에서 거리 계산
3. 거리 조건에 따라 CAN 데이터 설정
4. CAN 메시지 전송

이처럼 단일 루프에서 타이밍 기반으로 모든 기능을 수행하고 있으며,
기능이 추가될수록 타 작업 간 간섭, 우선순위 문제 등이 발생할 수 있다.

### RTOS 적용 시 기대 효과
- 실시간성 향상
    - 초음파 센서 트리거, 거리 계산 결과 송신 등을 Task 단위로 분리
    - 예: SensorTask는 거리 측정 및 해석만 수행, CommTask는 CAN 송신만 담당
    - 각 태스크는 우선순위를 설정하여 시간 민감 작업이 지연되지 않도록 보장

- 시스템 확장성 향상
    - 향후 OLED 출력, 배터리 상태 모니터링, 자가진단 기능 추가 시
    - 기존 로직 수정 없이 태스크만 추가하면 됨 → 구조적으로 깔끔하게 확장 가능

- 통신 안정성 및 데이터 보호
    - 태스크 간 거리 상태 등의 공유 정보는 Queue 또는 Message Buffer로 전달
    - 공유 자원(예: I2C OLED, CAN TX 버퍼 등)은 Mutex로 보호하여 여러 태스크가 동시에 접근하더라도 충돌 없이 동작 가능

### 단계별 RTOS 적용 계획
- 1단계: 기능 분리 및 태스크화
    - SensorTask : 일정 주기로 초음파 트리거 → 거리 측정 결과 저장
    - CommTask : 거리 정보를 읽고 CAN으로 전송
    - 필요 시 StatusTask : OLED나 UART로 거리 표시 등 부가 정보 출력

- 2단계: 태스크 간 통신 구조 적용
    - SensorTask → 거리 상태를 Queue 또는 Global 구조체로 전달
    - CommTask는 이를 읽어 CAN Tx 처리
    - 구조 분리로 향후 에러 핸들링, 디버깅도 명확해짐

- 3단계: 자원 보호 적용
    - I2C(OLED), CAN 송신 등은 Mutex 또는 Binary Semaphore로 보호
    - 동시에 접근할 수 있는 위험성을 방지하여 안정성 확보
