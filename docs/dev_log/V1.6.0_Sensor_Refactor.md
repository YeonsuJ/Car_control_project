# Sensor 부 파일 분할 및 코드 최적화, CAN 개선 (v1.6.0)

## 파일 분할 및 코드 최적화 목적

기존 sensor_v1.5.0은 모든 기능이 main.c 하나에 집중되어 있어 코드 복잡도가 높고 유지보수가 어려웠다. 특히, 초음파 센서 제어 로직과 CAN 메시지 송신 처리가 하나의 루프에서 직접 처리되며, 코드의 가독성 저하, 기능별 독립성 부족, 디버깅 어려움 등의 문제가 존재했다.
이를 해결하기 위해 sensor_v1.6.0에서는 다음과 같은 방식으로 기능별 모듈화 및 파일 분할을 수행하였다.

---

## 주요 변경 사항

### 1. 파일 분할 (모듈화)

기존 `main.c`의 역할을 분산시키고, 기능별 독립성을 확보하기 위해 아래와 같이 파일을 분할함

- `can_handler.c/.h` (CAN 통신 핸들러)
    - 역할: CAN 초기화 및 거리 조건에 따른 송신 데이터를 설정하고, 이를 CAN 메시지로 전송함. 송신 메시지는 다른 노드에서 위험 감지를 판단할 수 있도록 TxData[0]에 1 또는 0을 설정해 전송.

    - 주요 함수 : `CAN_tx_Init()` : CAN 시작 및 송신 헤더 설정, `CAN_Send()` : 설정된 데이터를 CAN 메시지로 전송

- `ultrasonic.c/.h` (초음파 센서 핸들러)
    - 역할 : 전방(PA9 트리거, PB6 에코) 및 후방(PA8 트리거, PB5 에코) 초음파 센서의 거리 측정을 담당함. 타이머 입력 캡처 인터럽트를 통해 Echo 신호를 측정하고, 거리값을 계산하여 전역 변수로 저장함.
    
    주요 함수 : `Ultrasonic_Init()` : 타이머 및 인터럽트 초기화, `Ultrasonic_Trigger()` : 두 초음파 센서에 트리거 신호 발생, `HAL_TIM_IC_CaptureCallback()` : 입력 캡처 인터럽트 기반 거리 측정 수행

- `main.c`의 역할 변경
    - 역할 : 시스템 초기화 이후 main() 루프에서 주기적으로 초음파 트리거를 발생시키고, 측정된 전방/후방 거리 값을 기반으로 위험 감지 여부를 판단하여 CAN 메시지를 송신함. 직접적인 거리 측정 로직이나 CAN 송신 코드는 모두 ultrasonic.c 및 can_handler.c에 위임되며, main.c는 전반적인 흐름을 조율하는 중재자(Coordinator) 역할을 수행함.

    - 주요 처리 로직:
        - 100ms 주기로 거리 측정 트리거
        - 전방 또는 후방 거리 중 하나라도 10cm 이하일 경우 위험 상태 전송 (TxData[0] = 1), 그렇지 않으면 안전 상태 전송 (TxData[0] = 0)

### 2. 코드 구조 최적화

파일 분할을 통해 아래와 같은 코드 구조 개선을 진행하였다.

#### 데이터 흐름 명확화
- 내용: 
    - 초음파 센서에서 측정된 거리 값은 ultrasonic.c 내부에서 distance_front, distance_rear 전역 변수에 저장된다.
    - main.c에서는 해당 거리 값을 기준으로 위험 여부를 판단하고, 이를 TxData[0]에 반영한 후 CAN_Send() 함수를 통해 메시지를 송신한다.
    - TxData[0]의 값(1: 위험, 0: 안전)은 수신 노드에서 햅틱 피드백 또는 OLED 출력 등에 활용된다.

- 효과 : 
    - 거리 측정 → 거리 판단 → CAN 전송이라는 단방향 흐름이 명확히 유지되며, 각 단계에서의 데이터 사용 위치가 명확하다.
    - 전역 변수의 혼용을 최소화하고, 각 모듈이 정의된 데이터 흐름만 처리하게 하여 디버깅과 추적이 용이해짐

#### 캡슐화 및 책임 분리
- 내용 : 
    - main.c는 더 이상 거리 측정 세부 처리(IC 캡처, 타이머 설정)나 CAN 전송 데이터 구성 세부 사항을 직접 다루지 않는다.
    - ultrasonic.c는 거리 측정만, can_handler.c는 송신 메시지 처리만 담당한다.
    - main.c는 타 주기적 로직의 흐름 제어만 담당하며, 하드웨어 세부 동작은 각 모듈에 위임됨
        - 예: Ultrasonic_Trigger()는 트리거 신호만 발생시킴 (내부 딜레이 포함)
        - CAN_Send()는 설정된 TxData[]를 이용해 송신만 수행하며, 메시지 구성은 main.c에서 판단하여 설정

- 효과 :
    - 각 모듈이 명확한 책임을 가지므로 모듈 간 결합도가 낮아지고,
    - 기능 추가/수정 시 다른 파일에 영향을 거의 주지 않음
    - 단위 테스트 또는 모듈 단독 테스트 수행이 쉬워져 유지보수성 및 확장성이 향상됨 

### 3. 주요 개선 사항: 통신 성능 최적화

sensor_v1.6.0에서는 초음파 거리 감지 결과를 보다 빠르고 안정적으로 전송하기 위해 CAN 통신 성능 최적화를 중점적으로 수행하였다. 이를 통해 거리 정보의 실시간 전송이 가능해졌으며, 햅틱 반응 등 응답성이 요구되는 기능에서도 End-to-End 지연 시간을 최소화하였다.

#### CAN 통신 최적화
1. 보드레이트 향상
    - CAN의 Prescaler 값을 72 → 18로 조정하여, 125kbps → 500kbps의 고속 통신 환경으로 개선함.
    - 초음파 센서 측정 후 거리 정보 전송 딜레이가 크게 감소, 햅틱 등 수신 노드의 반응 시간이 단축됨.

2. 자동 재전송 및 오류 복구 기능 활성화
    - AutoBusOff, AutoRetransmission 기능을 활성화하여 일시적 충돌이나 에러 상황에서도 자동으로 복구 및 재송신이 수행되도록 설정.
    - 안정적인 CAN 통신 유지로, 거리 정보가 누락되지 않으며 실시간성을 보장함.

3. 송신 데이터 패킷 구조 단순화
    - 거리 정보는 위험/안전 신호만 전달하므로 TxData[0] 하나의 바이트만 사용.
    - 패킷 구성 단순화로 전송 시간이 최소화되며, 불필요한 CAN 버스 사용률을 낮춤

#### 개선 효과

- End-to-End 지연 시간 최소화 : 초음파 트리거 → 거리 측정 → CAN 전송 → 수신 노드 반응까지의 전체 흐름이 최적화되어, 거리 변화에 대한 시스템 반응이 즉각적으로 동작함

- 시스템 안정성 향상 : 일시적인 에러나 노이즈 상황에서도 자동 복구 기능으로 연속적인 거리 상태 전송이 보장되며, 수신 누락 가능성이 현저히 감소

- 확장성 기반 마련 : 고속 CAN 설정을 통해 이후 다중 거리 센서, 다양한 경고 장치, 여러 수신 노드가 존재하는 구조로의 확장도 무리 없이 대응 가능

---

## 주요 코드 설명

### `can_handler.h`: CAN 통신 모듈 인터페이스 정의
```c
#ifndef INC_CAN_TX_HANDLER_H_
#define INC_CAN_TX_HANDLER_H_

#include "main.h"

extern CAN_TxHeaderTypeDef TxHeader;
extern uint32_t TxMailbox;
extern uint8_t TxData[8];

void CAN_tx_Init(void);   // HAL_CAN_Start 및 헤더 설정
void CAN_Send(void);      // TxData[0] 전송

#endif /* INC_CAN_TX_HANDLER_H_ */
```
- CAN_tx_Init()
    - CAN 통신을 시작하고, 송신용 TxHeader를 설정 (표준 ID, Data Frame, DLC = 8)
    - 메시지 전송을 위한 기본 설정 함수

- CAN_Send()
    - TxData[] 배열에 설정된 데이터를 CAN 메시지로 전송
    - 센서부에서는 TxData[0]에 위험 여부(1 또는 0)를 설정하여 전송함

- extern 변수
    - TxHeader, TxMailbox, TxData[]를 다른 모듈(main.c 등)에서 접근할 수 있도록 외부 선언 처리

### `can_handler.c`: CAN 통신 모듈 구현
```c
#include "can_handler.h"
#include "can.h"

CAN_TxHeaderTypeDef TxHeader;
uint32_t TxMailbox;
uint8_t TxData[8]; // 외부 접근을 위해 전역 선언

void CAN_tx_Init(void)
{
	HAL_CAN_Start(&hcan);

	TxHeader.DLC = 8;  // Data Length = 8 bytes
	TxHeader.IDE = CAN_ID_STD;
	TxHeader.RTR = CAN_RTR_DATA;
	TxHeader.StdId = 0x6A5;  // 송신 ID (수신 노드들이 필터링 가능하도록 설정)
}

void CAN_Send(void)
{
	HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox);
}
```

- HAL_CAN_Start()
    - CAN 컨트롤러를 시작하여 통신 가능 상태로 진입

- TxHeader 설정
    - StdId = 0x6A5 → 거리 정보 전용 송신 ID
    - DLC = 8이지만 실제로 사용하는 데이터는 TxData[0] 하나로 충분하며, 나머지는 0

HAL_CAN_AddTxMessage()

TxHeader, TxData[], TxMailbox를 이용해 메시지를 CAN 버스에 전송

센서부에서는 주기적으로 거리 조건 판단 후 호출됨

### `rf_handler.h`: RF 통신 모듈 인터페이스 정의
```c
#ifndef INC_RF_HANDLER_H_
#define INC_RF_HANDLER_H_

#include "main.h"
#include <stdbool.h>

// ▶ 수신된 주행 명령 데이터를 담는 구조체
typedef struct {
    float roll;
    uint16_t accel_ms;
    uint16_t brake_ms;
    uint8_t direction;
} VehicleCommand_t;

// ▶ NRF24 초기화 (수신모드 설정)
void RFHandler_Init(void);

// ▶ EXTI 인터럽트 발생 시 호출 (nRF IRQ 핀)
void RFHandler_IrqCallback(void);

// ▶ 다음 ACK 페이로드 데이터를 설정 (e.g. can_distance_signal)
void RFHandler_SetAckPayload(uint8_t signal);

// ▶ 새로운 주행 명령 수신 여부 확인 및 파싱
bool RFHandler_GetNewCommand(VehicleCommand_t* command);

#endif /* INC_RF_HANDLER_H_ */
```
- 외부에서 사용할 수 있는 초기화 함수, IRQ 콜백, ACK 설정 및 수신 명령 파싱 기능이 선언되어 있음

### `rf_handler.c`: RF 통신 모듈 구현
```c
#include "rf_handler.h"
#include "NRF24.h"
#include "NRF24_reg_addresses.h"
#include <string.h>

// ▶ 페이로드 크기 정의
#define RX_PAYLOAD_SIZE 8
#define ACK_PAYLOAD_SIZE 2

// ▶ 내부 상태 변수
static volatile uint8_t nrf_irq_flag = 0;             // IRQ 발생 여부
static uint8_t ack_response[ACK_PAYLOAD_SIZE] = {0};  // 다음 전송할 ACK 페이로드

// ▶ NRF24 모듈 초기화 (수신 전용)
void RFHandler_Init(void)
{
    static uint8_t rx_addr[5] = {0x45, 0x55, 0x67, 0x10, 0x21};

    csn_high(); HAL_Delay(5); ce_low();
    nrf24_init();
    nrf24_auto_ack_all(enable);
    nrf24_en_ack_pld(enable);       // ACK payload 활성화
    nrf24_dpl(disable);
    nrf24_set_crc(enable, _1byte);
    nrf24_tx_pwr(_0dbm);
    nrf24_data_rate(_2mbps);        // 속도 설정
    nrf24_set_channel(90);
    nrf24_set_addr_width(5);
    nrf24_open_rx_pipe(1, rx_addr);
    nrf24_pipe_pld_size(1, RX_PAYLOAD_SIZE);
    nrf24_listen();
}

// ▶ 외부 인터럽트 핸들러에서 호출되는 콜백
void RFHandler_IrqCallback(void)
{
    nrf_irq_flag = 1;
}

// ▶ 다음 ACK 페이로드 설정 함수
void RFHandler_SetAckPayload(uint8_t signal)
{
    ack_response[0] = signal;  // can_distance_signal 등 설정
}

// ▶ 새 데이터 수신 여부 확인 및 명령 파싱
bool RFHandler_GetNewCommand(VehicleCommand_t* command)
{
    if (!nrf_irq_flag) return false;

    nrf_irq_flag = 0;
    uint8_t status = nrf24_r_status();

    if (status & (1 << RX_DR))
    {
        uint8_t rx_buffer[RX_PAYLOAD_SIZE] = {0};
        nrf24_receive(rx_buffer, RX_PAYLOAD_SIZE);

        // ACK 페이로드 응답 전송
        nrf24_transmit_rx_ack_pld(1, ack_response, ACK_PAYLOAD_SIZE);
        nrf24_clear_rx_dr();

        if (rx_buffer[0] == 1) // 주행 명령
        {
            int16_t roll_encoded;
            memcpy(&roll_encoded, &rx_buffer[1], sizeof(int16_t));
            command->roll = ((float)roll_encoded) / 100.0f;

            memcpy(&command->accel_ms, &rx_buffer[3], sizeof(uint16_t));
            memcpy(&command->brake_ms, &rx_buffer[5], sizeof(uint16_t));
            command->direction = rx_buffer[7];

            return true;
        }
    }

    return false;
}
```

- NRF24 수신 초기화
    - RFHandler_Init()은 NRF24L01을 수신 모드로 설정하고, 자동 응답(ACK) + 페이로드 포함 전송 기능을 활성화한다.
    - 데이터 레이트 2Mbps, 채널 90, 주소 폭 5바이트, 파이프 1번 사용 등 실시간 제어에 최적화된 설정이 적용된다.
    - 목적: 컨트롤러와의 고속 양방향 통신을 위한 하드웨어 설정

- 인터럽트 기반 비동기 수신
    - EXTI 인터럽트가 발생하면 nrf_irq_flag를 세팅하여 메인 루프나 작업자 함수가 비동기적으로 수신 처리를 할 수 있도록 설계
    - 목적: 폴링이 아닌 인터럽트 기반 수신 처리 → CPU 점유율 최소화

- 주행 명령 파싱 및 구조화
    - rx_buffer에서 받은 바이트를 해석하여 VehicleCommand_t 구조체로 변환
        - roll (int16 → float 변환)
        - accel_ms, brake_ms, direction
    - 목적: 실수 없이 정형화된 주행 명령 데이터로 모터 제어 모듈에 직접 전달 가능

- ACK 페이로드 기반 상태 응답
    - RF 수신 시 nrf24_transmit_rx_ack_pld()를 통해 즉시 ACK 페이로드 전송.
    - can_handler에서 받은 can_distance_signal을 사전에 ack_response[0]에 담아 사용.
    - 목적: 컨트롤러에서 즉시 거리 상태 확인 가능, 햅틱 피드백 동기화

### `motor_control.h` : 모터 제어 모듈 인터페이스
```c
#ifndef INC_MOTOR_CONTROL_H_
#define INC_MOTOR_CONTROL_H_

#include "main.h"
#include "rf_handler.h" // VehicleCommand_t 사용을 위해 포함

/**
 * @brief 모든 모터 관련 주변장치(PWM, 방향핀, 엔코더 등) 초기화
 */
void MotorControl_Init(void);

/**
 * @brief 수신된 주행 명령에 따라 서보 및 DC모터를 제어
 * @param command: roll, accel, brake, direction 정보를 담은 구조체
 */
void MotorControl_Update(const VehicleCommand_t* command);

/**
 * @brief 현재 DC 모터의 RPM을 반환
 */
float MotorControl_GetRPM(void);

#endif /* INC_MOTOR_CONTROL_H_ */
```
- DC 모터 및 서보 모터의 제어 기능을 외부에 제공하며, 주행 명령 구조체(VehicleCommand_t) 기반 제어 함수 및 RPM 측정 함수가 선언되어 있다.

### `motor_control..c`: 모터 제어 모듈 구현
```c
#include "motor_control.h"
#include <math.h> // fabsf

// 타이머 외부 참조 (STM32CubeMX에서 생성된 핸들 사용)
extern TIM_HandleTypeDef htim1; // DC 모터 PWM
extern TIM_HandleTypeDef htim2; // 서보 모터 PWM
extern TIM_HandleTypeDef htim4; // 엔코더 입력

// 내부 설정 변수
static TIM_HandleTypeDef* dc_motor_htim = &htim1;
static uint32_t dc_motor_channel = TIM_CHANNEL_4;

static TIM_HandleTypeDef* servo_htim = &htim2;
static uint32_t servo_channel = TIM_CHANNEL_3;

static float motor_rpm = 0.0f;

// === RPM 계산용 매크로 및 상수 ===
#define PPR 11
#define GEAR_RATIO 21.3f
#define TICKS_PER_REV (PPR * GEAR_RATIO * 4)

// 모터 방향 전환 매크로
#define MOTOR_FORWARD()  do { HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); } while(0)
#define MOTOR_BACKWARD() do { HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET); } while(0)

typedef enum {
    DIRECTION_BACKWARD = 0,
    DIRECTION_FORWARD  = 1
} MotorDirection_t;

// === 초기화 함수 ===
void MotorControl_Init(void)
{
    HAL_TIM_PWM_Start(dc_motor_htim, dc_motor_channel);
    HAL_TIM_PWM_Start(servo_htim, servo_channel);
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
    MOTOR_FORWARD(); // 기본 방향
}

// === 전체 명령 기반 제어 함수 ===
void MotorControl_Update(const VehicleCommand_t* command)
{
    Update_Motor_RPM();
    Update_MotorDirection((MotorDirection_t)command->direction);
    Control_Servo(command->roll);
    Control_DcMotor(command->accel_ms, command->brake_ms);
}

// === 현재 RPM 반환 함수 ===
float MotorControl_GetRPM(void)
{
    return motor_rpm;
}

// === 내부 전용 함수 ===

static void Update_Motor_RPM(void)
{
    static int16_t last_encoder = 0;
    static uint32_t last_tick = 0;
    uint32_t now = HAL_GetTick();

    if (now - last_tick >= 100) // 100ms 주기
    {
        last_tick = now;
        int16_t enc = (int16_t)__HAL_TIM_GET_COUNTER(&htim4);
        int16_t delta = enc - last_encoder;
        last_encoder = enc;

        motor_rpm = fabsf(((float)delta / TICKS_PER_REV) * 10.0f * 60.0f);
    }
}

static void Control_Servo(float roll)
{
    if (roll < -90.0f) roll = -90.0f;
    if (roll >  90.0f) roll =  90.0f;
    float angle = roll + 90.0f;
    uint16_t pwm = (uint16_t)(1200 + (angle / 180.0f) * (1900 - 1200));
    __HAL_TIM_SET_COMPARE(servo_htim, servo_channel, pwm);
}

static void Control_DcMotor(uint16_t accel_ms, uint16_t brake_ms)
{
    static int16_t duty = 0;
    const int16_t accel_step = 50;
    const int16_t brake_step = 100;
    const int16_t max_duty = 1000;

    if (brake_ms > 0) duty -= brake_step;
    else if (accel_ms > 0) {
        if (duty == 0) duty = 300;
        duty += accel_step;
    } else {
        duty -= accel_step;
    }

    if (duty < 0) duty = 0;
    if (duty > max_duty) duty = max_duty;
    __HAL_TIM_SET_COMPARE(dc_motor_htim, dc_motor_channel, duty);
}

static void Update_MotorDirection(MotorDirection_t direction)
{
    static MotorDirection_t prev = DIRECTION_FORWARD;
    if (direction != prev) {
        prev = direction;
        if (direction == DIRECTION_FORWARD) MOTOR_FORWARD();
        else MOTOR_BACKWARD();
    }
}
```
- PWM 기반 제어
    - 서보 모터: roll 값을 -90° +90° 범위로 매핑 → 1200 1900us PWM 출력
    - DC 모터: PWM duty 비율을 accel_ms, brake_ms에 따라 가감속 제어
    - 목적: 사용자 입력에 따라 정밀한 속도 및 조향 제어

- DC 모터 방향 제어 (GPIO)
    - IN1/IN2 핀을 이용한 정/역회전 제어 (MOTOR_FORWARD(), MOTOR_BACKWARD() 매크로)
    - 이전 방향 상태와 비교 후 변경 시에만 핀 전환
    - 목적: 방향 전환 시 노이즈 및 급격한 반전 방지

- 엔코더 기반 실시간 RPM 측정
    - 100ms 주기로 엔코더 카운터 변화량 계산 → 기어비와 PPR 고려하여 RPM 산출
    - fabsf()를 통해 항상 양수 출력
    - 목적: 속도 피드백 기반 향후 PID 제어 등 확장 기반 마련

- 명령 구조체 기반 전체 제어 통합
    - MotorControl_Update() 함수는 외부에서 받은 VehicleCommand_t 구조체 하나만으로 전체 모터 상태(조향, 가감속, 방향)를 통합 제어
    - 목적: 외부 모듈과의 연계성을 높이고 코드 유지보수 간소화

### `main.c` 의 개선

이전의 main.c는 모든 기능이 한 파일에 집중되어 있었다. RF 수신, 데이터 파싱, 모터 제어, 방향 전환, CAN 응답 생성까지 모두 main() 함수 안에서 직접 처리했다. 구조가 복잡하고 가독성이 낮았으며, 유지보수나 기능 확장 시 전체 코드에 영향을 주기 쉬웠다.

반면 v1.6.0 구조에서는 이러한 책임을 모듈별로 분리했다. main() 함수는 다음과 같이 단순화되었다:

```c
while (1)
{
    if (RFHandler_GetNewCommand(&command))
    {
        MotorControl_Update(&command);
    }

    RFHandler_SetAckPayload(can_distance_signal);
}
```

이제 main.c는 RF로부터 명령을 받아 모터를 제어하고, 거리 상태를 응답에 포함하는 중재자 역할만 수행한다. 세부 로직은 rf_handler, motor_control, can_handler 등 각 파일에서 처리된다.

이로 인해 얻는 이점은 다음과 같다:

- 가독성 향상: 흐름이 단순하고 직관적이다.
- 유지보수 용이: 문제 발생 시 관련 모듈만 보면 된다.
- 확장성 증가: 새로운 기능을 별도 모듈로 추가하기 쉽다.

즉, v1.6.0은 기존의 복잡한 구조를 모듈화된 구조로 최적화하여, 실시간성·유지보수성·확장성을 모두 향상시켰다.

---

## 향후 확장 방향: RTOS 도입을 통한 시스템 고도화

v1.6.0에서 완성된 모듈화 구조는 while(1) 루프 기반의 순차적 처리 방식(Superloop)을 넘어,
실시간 운영체제(RTOS)를 도입하기 위한 훌륭한 기반이 되었다.
향후 시스템의 실시간성, 안정성, 확장성을 극대화하기 위해 FreeRTOS 도입을 목표로 한다.

### RTOS 도입의 필요성 및 기대 효과

현재 구조는 컨트롤러 입력(RF), DC/서보 모터 제어, CAN 거리 신호 수신 및 햅틱 제어 등 다양한 작업을 하나의 메인 루프에서 순차적으로 수행하고 있다.
이 방식은 간단하지만, 기능이 증가할수록 특정 작업이 다른 작업의 실행을 지연시키는 문제가 발생한다.
FreeRTOS와 같은 RTOS를 도입하면 이러한 문제를 해결하고 다음과 같은 효과를 기대할 수 있다:

- 실시간 응답성 확보 : 컨트롤러 입력 수신, CAN 거리 신호 반응, 햅틱 출력과 같은 시간 민감 작업을 각각 독립적인 태스크(Task)로 분리하고, 우선순위를 설정할 수 있다.
예를 들어, OLED 상태 표시와 같은 작업이 모터 제어나 무선 수신을 지연시키는 일을 방지할 수 있다.

- 시스템 확장성 향상 : 현재의 NRF24 수신 처리(RFHandler)나 모터 제어(MotorControl) 로직을 각각 InputTask, ControlTask 등으로 분리함으로써, 추후 GPS 수신, 배터리 모니터링, 데이터 로깅, 장애 감지 등 새로운 기능을 추가할 때 별도의 태스크만 정의하면 되므로 기존 코드 변경 없이 기능을 확장할 수 있다.

- 안정적인 통신 및 자원 보호 : 태스크 간 데이터 전달은 현재의 GetNewCommand() 방식 대신 Message Queue를 통해 처리할 수 있다. 예를 들어, InputTask가 수신한 컨트롤러 데이터를 큐에 넣고, MotorControlTask가 이를 큐에서 받아 처리하면 모듈 간 결합도를 낮추고 동기화를 보다 확실하게 유지할 수 있다.

또한 NRF24(SPI) 또는 SSD1306(I2C) 등 공유 자원 접근은 뮤텍스(Mutex)나 세마포(Semaphore)를 통해 보호하여 다중 태스크 환경에서도 안정적으로 하드웨어를 사용할 수 있다.

### 단계별 적용 계획
- 단계: 태스크 분리
    - `RFHandler` 로직을 `InputTask`로, `MotorControl` 및 RF 응답 처리를 `ControlTask` 또는 `CommTask`로 분리하여 독립적인 FreeRTOS 태스크로 전환한다.

- 2단계: 태스크 간 통신 구조 변경
    - `InputTask`는 수신한 조종 데이터를 구조체 형태로 메시지 큐에 전송하고, `CommTask`는 해당 큐로부터 데이터를 수신하여 모터 제어나 ACK 응답 처리에 활용한다.

- 3단계: 공유 자원 보호 적용 : SPI(NRF24), I2C(OLED) 등의 버스 자원은 Mutex로 보호하여,
여러 태스크가 동시에 접근할 경우에도 충돌이나 데이터 손상 없이 안정적인 운영을 보장한다.